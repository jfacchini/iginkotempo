/* soapC.cpp
   Generated by gSOAP 2.7.15 from TempoAPI.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.15 2010-03-18 13:33:34 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_PointerTo_ns1__verifBornePersoResponse:
		return soap_in_PointerTo_ns1__verifBornePersoResponse(soap, NULL, NULL, "ns1:verifBornePersoResponse");
	case SOAP_TYPE_PointerTo_ns1__verifBornePerso:
		return soap_in_PointerTo_ns1__verifBornePerso(soap, NULL, NULL, "ns1:verifBornePerso");
	case SOAP_TYPE_PointerTo_ns1__createBornePersoResponse:
		return soap_in_PointerTo_ns1__createBornePersoResponse(soap, NULL, NULL, "ns1:createBornePersoResponse");
	case SOAP_TYPE_PointerTo_ns1__createBornePerso:
		return soap_in_PointerTo_ns1__createBornePerso(soap, NULL, NULL, "ns1:createBornePerso");
	case SOAP_TYPE_PointerTo_ns1__deleteLigneStationBornePersoResponse:
		return soap_in_PointerTo_ns1__deleteLigneStationBornePersoResponse(soap, NULL, NULL, "ns1:deleteLigneStationBornePersoResponse");
	case SOAP_TYPE_PointerTo_ns1__deleteLigneStationBornePerso:
		return soap_in_PointerTo_ns1__deleteLigneStationBornePerso(soap, NULL, NULL, "ns1:deleteLigneStationBornePerso");
	case SOAP_TYPE_PointerTo_ns1__addLigneStationBornePersoResponse:
		return soap_in_PointerTo_ns1__addLigneStationBornePersoResponse(soap, NULL, NULL, "ns1:addLigneStationBornePersoResponse");
	case SOAP_TYPE_PointerTo_ns1__addLigneStationBornePerso:
		return soap_in_PointerTo_ns1__addLigneStationBornePerso(soap, NULL, NULL, "ns1:addLigneStationBornePerso");
	case SOAP_TYPE_PointerTo_ns1__getLigneStationBornePersoResponse:
		return soap_in_PointerTo_ns1__getLigneStationBornePersoResponse(soap, NULL, NULL, "ns1:getLigneStationBornePersoResponse");
	case SOAP_TYPE_PointerTo_ns1__getLigneStationBornePerso:
		return soap_in_PointerTo_ns1__getLigneStationBornePerso(soap, NULL, NULL, "ns1:getLigneStationBornePerso");
	case SOAP_TYPE_PointerTo_ns1__getInfoTraficResponse:
		return soap_in_PointerTo_ns1__getInfoTraficResponse(soap, NULL, NULL, "ns1:getInfoTraficResponse");
	case SOAP_TYPE_PointerTo_ns1__getInfoTrafic:
		return soap_in_PointerTo_ns1__getInfoTrafic(soap, NULL, NULL, "ns1:getInfoTrafic");
	case SOAP_TYPE_PointerTo_ns1__getTempsParStationResponse:
		return soap_in_PointerTo_ns1__getTempsParStationResponse(soap, NULL, NULL, "ns1:getTempsParStationResponse");
	case SOAP_TYPE_PointerTo_ns1__getTempsParStation:
		return soap_in_PointerTo_ns1__getTempsParStation(soap, NULL, NULL, "ns1:getTempsParStation");
	case SOAP_TYPE_PointerTo_ns1__getListeStationsProchesResponse:
		return soap_in_PointerTo_ns1__getListeStationsProchesResponse(soap, NULL, NULL, "ns1:getListeStationsProchesResponse");
	case SOAP_TYPE_PointerTo_ns1__getListeStationsProches:
		return soap_in_PointerTo_ns1__getListeStationsProches(soap, NULL, NULL, "ns1:getListeStationsProches");
	case SOAP_TYPE_PointerTo_ns1__getListeStationsParLigneResponse:
		return soap_in_PointerTo_ns1__getListeStationsParLigneResponse(soap, NULL, NULL, "ns1:getListeStationsParLigneResponse");
	case SOAP_TYPE_PointerTo_ns1__getListeStationsParLigne:
		return soap_in_PointerTo_ns1__getListeStationsParLigne(soap, NULL, NULL, "ns1:getListeStationsParLigne");
	case SOAP_TYPE_PointerTo_ns1__getListeStationsResponse:
		return soap_in_PointerTo_ns1__getListeStationsResponse(soap, NULL, NULL, "ns1:getListeStationsResponse");
	case SOAP_TYPE_PointerTo_ns1__getListeStations:
		return soap_in_PointerTo_ns1__getListeStations(soap, NULL, NULL, "ns1:getListeStations");
	case SOAP_TYPE_PointerTo_ns1__getListeLignesResponse:
		return soap_in_PointerTo_ns1__getListeLignesResponse(soap, NULL, NULL, "ns1:getListeLignesResponse");
	case SOAP_TYPE_PointerTo_ns1__getListeLignes:
		return soap_in_PointerTo_ns1__getListeLignes(soap, NULL, NULL, "ns1:getListeLignes");
	case SOAP_TYPE_PointerTo_ns1__getMessagesResponse:
		return soap_in_PointerTo_ns1__getMessagesResponse(soap, NULL, NULL, "ns1:getMessagesResponse");
	case SOAP_TYPE_PointerTo_ns1__getMessages:
		return soap_in_PointerTo_ns1__getMessages(soap, NULL, NULL, "ns1:getMessages");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:verifBornePersoResponse"))
		{	*type = SOAP_TYPE__ns1__verifBornePersoResponse;
			return soap_in__ns1__verifBornePersoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:verifBornePerso"))
		{	*type = SOAP_TYPE__ns1__verifBornePerso;
			return soap_in__ns1__verifBornePerso(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createBornePersoResponse"))
		{	*type = SOAP_TYPE__ns1__createBornePersoResponse;
			return soap_in__ns1__createBornePersoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createBornePerso"))
		{	*type = SOAP_TYPE__ns1__createBornePerso;
			return soap_in__ns1__createBornePerso(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteLigneStationBornePersoResponse"))
		{	*type = SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse;
			return soap_in__ns1__deleteLigneStationBornePersoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteLigneStationBornePerso"))
		{	*type = SOAP_TYPE__ns1__deleteLigneStationBornePerso;
			return soap_in__ns1__deleteLigneStationBornePerso(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addLigneStationBornePersoResponse"))
		{	*type = SOAP_TYPE__ns1__addLigneStationBornePersoResponse;
			return soap_in__ns1__addLigneStationBornePersoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addLigneStationBornePerso"))
		{	*type = SOAP_TYPE__ns1__addLigneStationBornePerso;
			return soap_in__ns1__addLigneStationBornePerso(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLigneStationBornePersoResponse"))
		{	*type = SOAP_TYPE__ns1__getLigneStationBornePersoResponse;
			return soap_in__ns1__getLigneStationBornePersoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLigneStationBornePerso"))
		{	*type = SOAP_TYPE__ns1__getLigneStationBornePerso;
			return soap_in__ns1__getLigneStationBornePerso(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInfoTraficResponse"))
		{	*type = SOAP_TYPE__ns1__getInfoTraficResponse;
			return soap_in__ns1__getInfoTraficResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInfoTrafic"))
		{	*type = SOAP_TYPE__ns1__getInfoTrafic;
			return soap_in__ns1__getInfoTrafic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTempsParStationResponse"))
		{	*type = SOAP_TYPE__ns1__getTempsParStationResponse;
			return soap_in__ns1__getTempsParStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTempsParStation"))
		{	*type = SOAP_TYPE__ns1__getTempsParStation;
			return soap_in__ns1__getTempsParStation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getListeStationsProchesResponse"))
		{	*type = SOAP_TYPE__ns1__getListeStationsProchesResponse;
			return soap_in__ns1__getListeStationsProchesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getListeStationsProches"))
		{	*type = SOAP_TYPE__ns1__getListeStationsProches;
			return soap_in__ns1__getListeStationsProches(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getListeStationsParLigneResponse"))
		{	*type = SOAP_TYPE__ns1__getListeStationsParLigneResponse;
			return soap_in__ns1__getListeStationsParLigneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getListeStationsParLigne"))
		{	*type = SOAP_TYPE__ns1__getListeStationsParLigne;
			return soap_in__ns1__getListeStationsParLigne(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getListeStationsResponse"))
		{	*type = SOAP_TYPE__ns1__getListeStationsResponse;
			return soap_in__ns1__getListeStationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getListeStations"))
		{	*type = SOAP_TYPE__ns1__getListeStations;
			return soap_in__ns1__getListeStations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getListeLignesResponse"))
		{	*type = SOAP_TYPE__ns1__getListeLignesResponse;
			return soap_in__ns1__getListeLignesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getListeLignes"))
		{	*type = SOAP_TYPE__ns1__getListeLignes;
			return soap_in__ns1__getListeLignes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMessagesResponse"))
		{	*type = SOAP_TYPE__ns1__getMessagesResponse;
			return soap_in__ns1__getMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMessages"))
		{	*type = SOAP_TYPE__ns1__getMessages;
			return soap_in__ns1__getMessages(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE__ns1__verifBornePersoResponse:
		return ((_ns1__verifBornePersoResponse *)ptr)->soap_out(soap, "ns1:verifBornePersoResponse", id, NULL);
	case SOAP_TYPE__ns1__verifBornePerso:
		return ((_ns1__verifBornePerso *)ptr)->soap_out(soap, "ns1:verifBornePerso", id, NULL);
	case SOAP_TYPE__ns1__createBornePersoResponse:
		return ((_ns1__createBornePersoResponse *)ptr)->soap_out(soap, "ns1:createBornePersoResponse", id, NULL);
	case SOAP_TYPE__ns1__createBornePerso:
		return ((_ns1__createBornePerso *)ptr)->soap_out(soap, "ns1:createBornePerso", id, NULL);
	case SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse:
		return ((_ns1__deleteLigneStationBornePersoResponse *)ptr)->soap_out(soap, "ns1:deleteLigneStationBornePersoResponse", id, NULL);
	case SOAP_TYPE__ns1__deleteLigneStationBornePerso:
		return ((_ns1__deleteLigneStationBornePerso *)ptr)->soap_out(soap, "ns1:deleteLigneStationBornePerso", id, NULL);
	case SOAP_TYPE__ns1__addLigneStationBornePersoResponse:
		return ((_ns1__addLigneStationBornePersoResponse *)ptr)->soap_out(soap, "ns1:addLigneStationBornePersoResponse", id, NULL);
	case SOAP_TYPE__ns1__addLigneStationBornePerso:
		return ((_ns1__addLigneStationBornePerso *)ptr)->soap_out(soap, "ns1:addLigneStationBornePerso", id, NULL);
	case SOAP_TYPE__ns1__getLigneStationBornePersoResponse:
		return ((_ns1__getLigneStationBornePersoResponse *)ptr)->soap_out(soap, "ns1:getLigneStationBornePersoResponse", id, NULL);
	case SOAP_TYPE__ns1__getLigneStationBornePerso:
		return ((_ns1__getLigneStationBornePerso *)ptr)->soap_out(soap, "ns1:getLigneStationBornePerso", id, NULL);
	case SOAP_TYPE__ns1__getInfoTraficResponse:
		return ((_ns1__getInfoTraficResponse *)ptr)->soap_out(soap, "ns1:getInfoTraficResponse", id, NULL);
	case SOAP_TYPE__ns1__getInfoTrafic:
		return ((_ns1__getInfoTrafic *)ptr)->soap_out(soap, "ns1:getInfoTrafic", id, NULL);
	case SOAP_TYPE__ns1__getTempsParStationResponse:
		return ((_ns1__getTempsParStationResponse *)ptr)->soap_out(soap, "ns1:getTempsParStationResponse", id, NULL);
	case SOAP_TYPE__ns1__getTempsParStation:
		return ((_ns1__getTempsParStation *)ptr)->soap_out(soap, "ns1:getTempsParStation", id, NULL);
	case SOAP_TYPE__ns1__getListeStationsProchesResponse:
		return ((_ns1__getListeStationsProchesResponse *)ptr)->soap_out(soap, "ns1:getListeStationsProchesResponse", id, NULL);
	case SOAP_TYPE__ns1__getListeStationsProches:
		return ((_ns1__getListeStationsProches *)ptr)->soap_out(soap, "ns1:getListeStationsProches", id, NULL);
	case SOAP_TYPE__ns1__getListeStationsParLigneResponse:
		return ((_ns1__getListeStationsParLigneResponse *)ptr)->soap_out(soap, "ns1:getListeStationsParLigneResponse", id, NULL);
	case SOAP_TYPE__ns1__getListeStationsParLigne:
		return ((_ns1__getListeStationsParLigne *)ptr)->soap_out(soap, "ns1:getListeStationsParLigne", id, NULL);
	case SOAP_TYPE__ns1__getListeStationsResponse:
		return ((_ns1__getListeStationsResponse *)ptr)->soap_out(soap, "ns1:getListeStationsResponse", id, NULL);
	case SOAP_TYPE__ns1__getListeStations:
		return ((_ns1__getListeStations *)ptr)->soap_out(soap, "ns1:getListeStations", id, NULL);
	case SOAP_TYPE__ns1__getListeLignesResponse:
		return ((_ns1__getListeLignesResponse *)ptr)->soap_out(soap, "ns1:getListeLignesResponse", id, NULL);
	case SOAP_TYPE__ns1__getListeLignes:
		return ((_ns1__getListeLignes *)ptr)->soap_out(soap, "ns1:getListeLignes", id, NULL);
	case SOAP_TYPE__ns1__getMessagesResponse:
		return ((_ns1__getMessagesResponse *)ptr)->soap_out(soap, "ns1:getMessagesResponse", id, NULL);
	case SOAP_TYPE__ns1__getMessages:
		return ((_ns1__getMessages *)ptr)->soap_out(soap, "ns1:getMessages", id, NULL);
	case SOAP_TYPE_PointerTo_ns1__verifBornePersoResponse:
		return soap_out_PointerTo_ns1__verifBornePersoResponse(soap, tag, id, (_ns1__verifBornePersoResponse *const*)ptr, "ns1:verifBornePersoResponse");
	case SOAP_TYPE_PointerTo_ns1__verifBornePerso:
		return soap_out_PointerTo_ns1__verifBornePerso(soap, tag, id, (_ns1__verifBornePerso *const*)ptr, "ns1:verifBornePerso");
	case SOAP_TYPE_PointerTo_ns1__createBornePersoResponse:
		return soap_out_PointerTo_ns1__createBornePersoResponse(soap, tag, id, (_ns1__createBornePersoResponse *const*)ptr, "ns1:createBornePersoResponse");
	case SOAP_TYPE_PointerTo_ns1__createBornePerso:
		return soap_out_PointerTo_ns1__createBornePerso(soap, tag, id, (_ns1__createBornePerso *const*)ptr, "ns1:createBornePerso");
	case SOAP_TYPE_PointerTo_ns1__deleteLigneStationBornePersoResponse:
		return soap_out_PointerTo_ns1__deleteLigneStationBornePersoResponse(soap, tag, id, (_ns1__deleteLigneStationBornePersoResponse *const*)ptr, "ns1:deleteLigneStationBornePersoResponse");
	case SOAP_TYPE_PointerTo_ns1__deleteLigneStationBornePerso:
		return soap_out_PointerTo_ns1__deleteLigneStationBornePerso(soap, tag, id, (_ns1__deleteLigneStationBornePerso *const*)ptr, "ns1:deleteLigneStationBornePerso");
	case SOAP_TYPE_PointerTo_ns1__addLigneStationBornePersoResponse:
		return soap_out_PointerTo_ns1__addLigneStationBornePersoResponse(soap, tag, id, (_ns1__addLigneStationBornePersoResponse *const*)ptr, "ns1:addLigneStationBornePersoResponse");
	case SOAP_TYPE_PointerTo_ns1__addLigneStationBornePerso:
		return soap_out_PointerTo_ns1__addLigneStationBornePerso(soap, tag, id, (_ns1__addLigneStationBornePerso *const*)ptr, "ns1:addLigneStationBornePerso");
	case SOAP_TYPE_PointerTo_ns1__getLigneStationBornePersoResponse:
		return soap_out_PointerTo_ns1__getLigneStationBornePersoResponse(soap, tag, id, (_ns1__getLigneStationBornePersoResponse *const*)ptr, "ns1:getLigneStationBornePersoResponse");
	case SOAP_TYPE_PointerTo_ns1__getLigneStationBornePerso:
		return soap_out_PointerTo_ns1__getLigneStationBornePerso(soap, tag, id, (_ns1__getLigneStationBornePerso *const*)ptr, "ns1:getLigneStationBornePerso");
	case SOAP_TYPE_PointerTo_ns1__getInfoTraficResponse:
		return soap_out_PointerTo_ns1__getInfoTraficResponse(soap, tag, id, (_ns1__getInfoTraficResponse *const*)ptr, "ns1:getInfoTraficResponse");
	case SOAP_TYPE_PointerTo_ns1__getInfoTrafic:
		return soap_out_PointerTo_ns1__getInfoTrafic(soap, tag, id, (_ns1__getInfoTrafic *const*)ptr, "ns1:getInfoTrafic");
	case SOAP_TYPE_PointerTo_ns1__getTempsParStationResponse:
		return soap_out_PointerTo_ns1__getTempsParStationResponse(soap, tag, id, (_ns1__getTempsParStationResponse *const*)ptr, "ns1:getTempsParStationResponse");
	case SOAP_TYPE_PointerTo_ns1__getTempsParStation:
		return soap_out_PointerTo_ns1__getTempsParStation(soap, tag, id, (_ns1__getTempsParStation *const*)ptr, "ns1:getTempsParStation");
	case SOAP_TYPE_PointerTo_ns1__getListeStationsProchesResponse:
		return soap_out_PointerTo_ns1__getListeStationsProchesResponse(soap, tag, id, (_ns1__getListeStationsProchesResponse *const*)ptr, "ns1:getListeStationsProchesResponse");
	case SOAP_TYPE_PointerTo_ns1__getListeStationsProches:
		return soap_out_PointerTo_ns1__getListeStationsProches(soap, tag, id, (_ns1__getListeStationsProches *const*)ptr, "ns1:getListeStationsProches");
	case SOAP_TYPE_PointerTo_ns1__getListeStationsParLigneResponse:
		return soap_out_PointerTo_ns1__getListeStationsParLigneResponse(soap, tag, id, (_ns1__getListeStationsParLigneResponse *const*)ptr, "ns1:getListeStationsParLigneResponse");
	case SOAP_TYPE_PointerTo_ns1__getListeStationsParLigne:
		return soap_out_PointerTo_ns1__getListeStationsParLigne(soap, tag, id, (_ns1__getListeStationsParLigne *const*)ptr, "ns1:getListeStationsParLigne");
	case SOAP_TYPE_PointerTo_ns1__getListeStationsResponse:
		return soap_out_PointerTo_ns1__getListeStationsResponse(soap, tag, id, (_ns1__getListeStationsResponse *const*)ptr, "ns1:getListeStationsResponse");
	case SOAP_TYPE_PointerTo_ns1__getListeStations:
		return soap_out_PointerTo_ns1__getListeStations(soap, tag, id, (_ns1__getListeStations *const*)ptr, "ns1:getListeStations");
	case SOAP_TYPE_PointerTo_ns1__getListeLignesResponse:
		return soap_out_PointerTo_ns1__getListeLignesResponse(soap, tag, id, (_ns1__getListeLignesResponse *const*)ptr, "ns1:getListeLignesResponse");
	case SOAP_TYPE_PointerTo_ns1__getListeLignes:
		return soap_out_PointerTo_ns1__getListeLignes(soap, tag, id, (_ns1__getListeLignes *const*)ptr, "ns1:getListeLignes");
	case SOAP_TYPE_PointerTo_ns1__getMessagesResponse:
		return soap_out_PointerTo_ns1__getMessagesResponse(soap, tag, id, (_ns1__getMessagesResponse *const*)ptr, "ns1:getMessagesResponse");
	case SOAP_TYPE_PointerTo_ns1__getMessages:
		return soap_out_PointerTo_ns1__getMessages(soap, tag, id, (_ns1__getMessages *const*)ptr, "ns1:getMessages");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__verifBornePersoResponse:
		((_ns1__verifBornePersoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__verifBornePerso:
		((_ns1__verifBornePerso *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__createBornePersoResponse:
		((_ns1__createBornePersoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__createBornePerso:
		((_ns1__createBornePerso *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse:
		((_ns1__deleteLigneStationBornePersoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__deleteLigneStationBornePerso:
		((_ns1__deleteLigneStationBornePerso *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addLigneStationBornePersoResponse:
		((_ns1__addLigneStationBornePersoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addLigneStationBornePerso:
		((_ns1__addLigneStationBornePerso *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getLigneStationBornePersoResponse:
		((_ns1__getLigneStationBornePersoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getLigneStationBornePerso:
		((_ns1__getLigneStationBornePerso *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getInfoTraficResponse:
		((_ns1__getInfoTraficResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getInfoTrafic:
		((_ns1__getInfoTrafic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTempsParStationResponse:
		((_ns1__getTempsParStationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTempsParStation:
		((_ns1__getTempsParStation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getListeStationsProchesResponse:
		((_ns1__getListeStationsProchesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getListeStationsProches:
		((_ns1__getListeStationsProches *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getListeStationsParLigneResponse:
		((_ns1__getListeStationsParLigneResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getListeStationsParLigne:
		((_ns1__getListeStationsParLigne *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getListeStationsResponse:
		((_ns1__getListeStationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getListeStations:
		((_ns1__getListeStations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getListeLignesResponse:
		((_ns1__getListeLignesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getListeLignes:
		((_ns1__getListeLignes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMessagesResponse:
		((_ns1__getMessagesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMessages:
		((_ns1__getMessages *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__verifBornePerso:
		soap_serialize___ns1__verifBornePerso(soap, (const struct __ns1__verifBornePerso *)ptr);
		break;
	case SOAP_TYPE___ns1__createBornePerso:
		soap_serialize___ns1__createBornePerso(soap, (const struct __ns1__createBornePerso *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteLigneStationBornePerso:
		soap_serialize___ns1__deleteLigneStationBornePerso(soap, (const struct __ns1__deleteLigneStationBornePerso *)ptr);
		break;
	case SOAP_TYPE___ns1__addLigneStationBornePerso:
		soap_serialize___ns1__addLigneStationBornePerso(soap, (const struct __ns1__addLigneStationBornePerso *)ptr);
		break;
	case SOAP_TYPE___ns1__getLigneStationBornePerso:
		soap_serialize___ns1__getLigneStationBornePerso(soap, (const struct __ns1__getLigneStationBornePerso *)ptr);
		break;
	case SOAP_TYPE___ns1__getInfoTrafic:
		soap_serialize___ns1__getInfoTrafic(soap, (const struct __ns1__getInfoTrafic *)ptr);
		break;
	case SOAP_TYPE___ns1__getTempsParStation:
		soap_serialize___ns1__getTempsParStation(soap, (const struct __ns1__getTempsParStation *)ptr);
		break;
	case SOAP_TYPE___ns1__getListeStationsProches:
		soap_serialize___ns1__getListeStationsProches(soap, (const struct __ns1__getListeStationsProches *)ptr);
		break;
	case SOAP_TYPE___ns1__getListeStationsParLigne:
		soap_serialize___ns1__getListeStationsParLigne(soap, (const struct __ns1__getListeStationsParLigne *)ptr);
		break;
	case SOAP_TYPE___ns1__getListeStations:
		soap_serialize___ns1__getListeStations(soap, (const struct __ns1__getListeStations *)ptr);
		break;
	case SOAP_TYPE___ns1__getListeLignes:
		soap_serialize___ns1__getListeLignes(soap, (const struct __ns1__getListeLignes *)ptr);
		break;
	case SOAP_TYPE___ns1__getMessages:
		soap_serialize___ns1__getMessages(soap, (const struct __ns1__getMessages *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__verifBornePersoResponse:
		soap_serialize_PointerTo_ns1__verifBornePersoResponse(soap, (_ns1__verifBornePersoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__verifBornePerso:
		soap_serialize_PointerTo_ns1__verifBornePerso(soap, (_ns1__verifBornePerso *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createBornePersoResponse:
		soap_serialize_PointerTo_ns1__createBornePersoResponse(soap, (_ns1__createBornePersoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createBornePerso:
		soap_serialize_PointerTo_ns1__createBornePerso(soap, (_ns1__createBornePerso *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__deleteLigneStationBornePersoResponse:
		soap_serialize_PointerTo_ns1__deleteLigneStationBornePersoResponse(soap, (_ns1__deleteLigneStationBornePersoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__deleteLigneStationBornePerso:
		soap_serialize_PointerTo_ns1__deleteLigneStationBornePerso(soap, (_ns1__deleteLigneStationBornePerso *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addLigneStationBornePersoResponse:
		soap_serialize_PointerTo_ns1__addLigneStationBornePersoResponse(soap, (_ns1__addLigneStationBornePersoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addLigneStationBornePerso:
		soap_serialize_PointerTo_ns1__addLigneStationBornePerso(soap, (_ns1__addLigneStationBornePerso *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getLigneStationBornePersoResponse:
		soap_serialize_PointerTo_ns1__getLigneStationBornePersoResponse(soap, (_ns1__getLigneStationBornePersoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getLigneStationBornePerso:
		soap_serialize_PointerTo_ns1__getLigneStationBornePerso(soap, (_ns1__getLigneStationBornePerso *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getInfoTraficResponse:
		soap_serialize_PointerTo_ns1__getInfoTraficResponse(soap, (_ns1__getInfoTraficResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getInfoTrafic:
		soap_serialize_PointerTo_ns1__getInfoTrafic(soap, (_ns1__getInfoTrafic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTempsParStationResponse:
		soap_serialize_PointerTo_ns1__getTempsParStationResponse(soap, (_ns1__getTempsParStationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTempsParStation:
		soap_serialize_PointerTo_ns1__getTempsParStation(soap, (_ns1__getTempsParStation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getListeStationsProchesResponse:
		soap_serialize_PointerTo_ns1__getListeStationsProchesResponse(soap, (_ns1__getListeStationsProchesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getListeStationsProches:
		soap_serialize_PointerTo_ns1__getListeStationsProches(soap, (_ns1__getListeStationsProches *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getListeStationsParLigneResponse:
		soap_serialize_PointerTo_ns1__getListeStationsParLigneResponse(soap, (_ns1__getListeStationsParLigneResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getListeStationsParLigne:
		soap_serialize_PointerTo_ns1__getListeStationsParLigne(soap, (_ns1__getListeStationsParLigne *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getListeStationsResponse:
		soap_serialize_PointerTo_ns1__getListeStationsResponse(soap, (_ns1__getListeStationsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getListeStations:
		soap_serialize_PointerTo_ns1__getListeStations(soap, (_ns1__getListeStations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getListeLignesResponse:
		soap_serialize_PointerTo_ns1__getListeLignesResponse(soap, (_ns1__getListeLignesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getListeLignes:
		soap_serialize_PointerTo_ns1__getListeLignes(soap, (_ns1__getListeLignes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getMessagesResponse:
		soap_serialize_PointerTo_ns1__getMessagesResponse(soap, (_ns1__getMessagesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getMessages:
		soap_serialize_PointerTo_ns1__getMessages(soap, (_ns1__getMessages *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE__ns1__getMessages:
		return (void*)soap_instantiate__ns1__getMessages(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getMessagesResponse:
		return (void*)soap_instantiate__ns1__getMessagesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getListeLignes:
		return (void*)soap_instantiate__ns1__getListeLignes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getListeLignesResponse:
		return (void*)soap_instantiate__ns1__getListeLignesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getListeStations:
		return (void*)soap_instantiate__ns1__getListeStations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getListeStationsResponse:
		return (void*)soap_instantiate__ns1__getListeStationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getListeStationsParLigne:
		return (void*)soap_instantiate__ns1__getListeStationsParLigne(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getListeStationsParLigneResponse:
		return (void*)soap_instantiate__ns1__getListeStationsParLigneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getListeStationsProches:
		return (void*)soap_instantiate__ns1__getListeStationsProches(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getListeStationsProchesResponse:
		return (void*)soap_instantiate__ns1__getListeStationsProchesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTempsParStation:
		return (void*)soap_instantiate__ns1__getTempsParStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTempsParStationResponse:
		return (void*)soap_instantiate__ns1__getTempsParStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getInfoTrafic:
		return (void*)soap_instantiate__ns1__getInfoTrafic(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getInfoTraficResponse:
		return (void*)soap_instantiate__ns1__getInfoTraficResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getLigneStationBornePerso:
		return (void*)soap_instantiate__ns1__getLigneStationBornePerso(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getLigneStationBornePersoResponse:
		return (void*)soap_instantiate__ns1__getLigneStationBornePersoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addLigneStationBornePerso:
		return (void*)soap_instantiate__ns1__addLigneStationBornePerso(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addLigneStationBornePersoResponse:
		return (void*)soap_instantiate__ns1__addLigneStationBornePersoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__deleteLigneStationBornePerso:
		return (void*)soap_instantiate__ns1__deleteLigneStationBornePerso(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse:
		return (void*)soap_instantiate__ns1__deleteLigneStationBornePersoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__createBornePerso:
		return (void*)soap_instantiate__ns1__createBornePerso(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__createBornePersoResponse:
		return (void*)soap_instantiate__ns1__createBornePersoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__verifBornePerso:
		return (void*)soap_instantiate__ns1__verifBornePerso(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__verifBornePersoResponse:
		return (void*)soap_instantiate__ns1__verifBornePersoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMessages:
		return (void*)soap_instantiate___ns1__getMessages(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getListeLignes:
		return (void*)soap_instantiate___ns1__getListeLignes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getListeStations:
		return (void*)soap_instantiate___ns1__getListeStations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getListeStationsParLigne:
		return (void*)soap_instantiate___ns1__getListeStationsParLigne(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getListeStationsProches:
		return (void*)soap_instantiate___ns1__getListeStationsProches(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTempsParStation:
		return (void*)soap_instantiate___ns1__getTempsParStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getInfoTrafic:
		return (void*)soap_instantiate___ns1__getInfoTrafic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getLigneStationBornePerso:
		return (void*)soap_instantiate___ns1__getLigneStationBornePerso(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addLigneStationBornePerso:
		return (void*)soap_instantiate___ns1__addLigneStationBornePerso(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteLigneStationBornePerso:
		return (void*)soap_instantiate___ns1__deleteLigneStationBornePerso(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createBornePerso:
		return (void*)soap_instantiate___ns1__createBornePerso(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__verifBornePerso:
		return (void*)soap_instantiate___ns1__verifBornePerso(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE__ns1__getMessages:
		if (p->size < 0)
			delete (_ns1__getMessages*)p->ptr;
		else
			delete[] (_ns1__getMessages*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getMessagesResponse:
		if (p->size < 0)
			delete (_ns1__getMessagesResponse*)p->ptr;
		else
			delete[] (_ns1__getMessagesResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getListeLignes:
		if (p->size < 0)
			delete (_ns1__getListeLignes*)p->ptr;
		else
			delete[] (_ns1__getListeLignes*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getListeLignesResponse:
		if (p->size < 0)
			delete (_ns1__getListeLignesResponse*)p->ptr;
		else
			delete[] (_ns1__getListeLignesResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getListeStations:
		if (p->size < 0)
			delete (_ns1__getListeStations*)p->ptr;
		else
			delete[] (_ns1__getListeStations*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getListeStationsResponse:
		if (p->size < 0)
			delete (_ns1__getListeStationsResponse*)p->ptr;
		else
			delete[] (_ns1__getListeStationsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getListeStationsParLigne:
		if (p->size < 0)
			delete (_ns1__getListeStationsParLigne*)p->ptr;
		else
			delete[] (_ns1__getListeStationsParLigne*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getListeStationsParLigneResponse:
		if (p->size < 0)
			delete (_ns1__getListeStationsParLigneResponse*)p->ptr;
		else
			delete[] (_ns1__getListeStationsParLigneResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getListeStationsProches:
		if (p->size < 0)
			delete (_ns1__getListeStationsProches*)p->ptr;
		else
			delete[] (_ns1__getListeStationsProches*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getListeStationsProchesResponse:
		if (p->size < 0)
			delete (_ns1__getListeStationsProchesResponse*)p->ptr;
		else
			delete[] (_ns1__getListeStationsProchesResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getTempsParStation:
		if (p->size < 0)
			delete (_ns1__getTempsParStation*)p->ptr;
		else
			delete[] (_ns1__getTempsParStation*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getTempsParStationResponse:
		if (p->size < 0)
			delete (_ns1__getTempsParStationResponse*)p->ptr;
		else
			delete[] (_ns1__getTempsParStationResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getInfoTrafic:
		if (p->size < 0)
			delete (_ns1__getInfoTrafic*)p->ptr;
		else
			delete[] (_ns1__getInfoTrafic*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getInfoTraficResponse:
		if (p->size < 0)
			delete (_ns1__getInfoTraficResponse*)p->ptr;
		else
			delete[] (_ns1__getInfoTraficResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getLigneStationBornePerso:
		if (p->size < 0)
			delete (_ns1__getLigneStationBornePerso*)p->ptr;
		else
			delete[] (_ns1__getLigneStationBornePerso*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getLigneStationBornePersoResponse:
		if (p->size < 0)
			delete (_ns1__getLigneStationBornePersoResponse*)p->ptr;
		else
			delete[] (_ns1__getLigneStationBornePersoResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__addLigneStationBornePerso:
		if (p->size < 0)
			delete (_ns1__addLigneStationBornePerso*)p->ptr;
		else
			delete[] (_ns1__addLigneStationBornePerso*)p->ptr;
		break;
	case SOAP_TYPE__ns1__addLigneStationBornePersoResponse:
		if (p->size < 0)
			delete (_ns1__addLigneStationBornePersoResponse*)p->ptr;
		else
			delete[] (_ns1__addLigneStationBornePersoResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__deleteLigneStationBornePerso:
		if (p->size < 0)
			delete (_ns1__deleteLigneStationBornePerso*)p->ptr;
		else
			delete[] (_ns1__deleteLigneStationBornePerso*)p->ptr;
		break;
	case SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse:
		if (p->size < 0)
			delete (_ns1__deleteLigneStationBornePersoResponse*)p->ptr;
		else
			delete[] (_ns1__deleteLigneStationBornePersoResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__createBornePerso:
		if (p->size < 0)
			delete (_ns1__createBornePerso*)p->ptr;
		else
			delete[] (_ns1__createBornePerso*)p->ptr;
		break;
	case SOAP_TYPE__ns1__createBornePersoResponse:
		if (p->size < 0)
			delete (_ns1__createBornePersoResponse*)p->ptr;
		else
			delete[] (_ns1__createBornePersoResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__verifBornePerso:
		if (p->size < 0)
			delete (_ns1__verifBornePerso*)p->ptr;
		else
			delete[] (_ns1__verifBornePerso*)p->ptr;
		break;
	case SOAP_TYPE__ns1__verifBornePersoResponse:
		if (p->size < 0)
			delete (_ns1__verifBornePersoResponse*)p->ptr;
		else
			delete[] (_ns1__verifBornePersoResponse*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getMessages:
		if (p->size < 0)
			delete (struct __ns1__getMessages*)p->ptr;
		else
			delete[] (struct __ns1__getMessages*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getListeLignes:
		if (p->size < 0)
			delete (struct __ns1__getListeLignes*)p->ptr;
		else
			delete[] (struct __ns1__getListeLignes*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getListeStations:
		if (p->size < 0)
			delete (struct __ns1__getListeStations*)p->ptr;
		else
			delete[] (struct __ns1__getListeStations*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getListeStationsParLigne:
		if (p->size < 0)
			delete (struct __ns1__getListeStationsParLigne*)p->ptr;
		else
			delete[] (struct __ns1__getListeStationsParLigne*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getListeStationsProches:
		if (p->size < 0)
			delete (struct __ns1__getListeStationsProches*)p->ptr;
		else
			delete[] (struct __ns1__getListeStationsProches*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getTempsParStation:
		if (p->size < 0)
			delete (struct __ns1__getTempsParStation*)p->ptr;
		else
			delete[] (struct __ns1__getTempsParStation*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getInfoTrafic:
		if (p->size < 0)
			delete (struct __ns1__getInfoTrafic*)p->ptr;
		else
			delete[] (struct __ns1__getInfoTrafic*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getLigneStationBornePerso:
		if (p->size < 0)
			delete (struct __ns1__getLigneStationBornePerso*)p->ptr;
		else
			delete[] (struct __ns1__getLigneStationBornePerso*)p->ptr;
		break;
	case SOAP_TYPE___ns1__addLigneStationBornePerso:
		if (p->size < 0)
			delete (struct __ns1__addLigneStationBornePerso*)p->ptr;
		else
			delete[] (struct __ns1__addLigneStationBornePerso*)p->ptr;
		break;
	case SOAP_TYPE___ns1__deleteLigneStationBornePerso:
		if (p->size < 0)
			delete (struct __ns1__deleteLigneStationBornePerso*)p->ptr;
		else
			delete[] (struct __ns1__deleteLigneStationBornePerso*)p->ptr;
		break;
	case SOAP_TYPE___ns1__createBornePerso:
		if (p->size < 0)
			delete (struct __ns1__createBornePerso*)p->ptr;
		else
			delete[] (struct __ns1__createBornePerso*)p->ptr;
		break;
	case SOAP_TYPE___ns1__verifBornePerso:
		if (p->size < 0)
			delete (struct __ns1__verifBornePerso*)p->ptr;
		else
			delete[] (struct __ns1__verifBornePerso*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__verifBornePersoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__verifBornePersoResponse::verifBornePersoReturn);
	/* transient soap skipped */
}

void _ns1__verifBornePersoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__verifBornePersoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__verifBornePersoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__verifBornePersoResponse(struct soap *soap, const char *tag, int id, const _ns1__verifBornePersoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__verifBornePersoResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:verifBornePersoReturn");
	if (soap_out_int(soap, "ns1:verifBornePersoReturn", -1, &(a->_ns1__verifBornePersoResponse::verifBornePersoReturn), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__verifBornePersoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__verifBornePersoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__verifBornePersoResponse * SOAP_FMAC4 soap_in__ns1__verifBornePersoResponse(struct soap *soap, const char *tag, _ns1__verifBornePersoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__verifBornePersoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__verifBornePersoResponse, sizeof(_ns1__verifBornePersoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__verifBornePersoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__verifBornePersoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_verifBornePersoReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_verifBornePersoReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:verifBornePersoReturn", &(a->_ns1__verifBornePersoResponse::verifBornePersoReturn), "xsd:int"))
				{	soap_flag_verifBornePersoReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:verifBornePersoReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__verifBornePersoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__verifBornePersoResponse, 0, sizeof(_ns1__verifBornePersoResponse), 0, soap_copy__ns1__verifBornePersoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_verifBornePersoReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__verifBornePersoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__verifBornePersoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:verifBornePersoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__verifBornePersoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__verifBornePersoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__verifBornePersoResponse * SOAP_FMAC4 soap_get__ns1__verifBornePersoResponse(struct soap *soap, _ns1__verifBornePersoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__verifBornePersoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__verifBornePersoResponse * SOAP_FMAC2 soap_instantiate__ns1__verifBornePersoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__verifBornePersoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__verifBornePersoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__verifBornePersoResponse);
		if (size)
			*size = sizeof(_ns1__verifBornePersoResponse);
		((_ns1__verifBornePersoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__verifBornePersoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__verifBornePersoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__verifBornePersoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__verifBornePersoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__verifBornePersoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__verifBornePersoResponse %p -> %p\n", q, p));
	*(_ns1__verifBornePersoResponse*)p = *(_ns1__verifBornePersoResponse*)q;
}

void _ns1__verifBornePerso::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__verifBornePerso::Idenditifiant);
	soap_default_string(soap, &this->_ns1__verifBornePerso::MotDePasseMD5);
	/* transient soap skipped */
}

void _ns1__verifBornePerso::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__verifBornePerso::Idenditifiant);
	soap_serialize_string(soap, &this->_ns1__verifBornePerso::MotDePasseMD5);
	/* transient soap skipped */
}

int _ns1__verifBornePerso::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__verifBornePerso(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__verifBornePerso(struct soap *soap, const char *tag, int id, const _ns1__verifBornePerso *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__verifBornePerso), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Idenditifiant", -1, &(a->_ns1__verifBornePerso::Idenditifiant), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MotDePasseMD5", -1, &(a->_ns1__verifBornePerso::MotDePasseMD5), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__verifBornePerso::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__verifBornePerso(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__verifBornePerso * SOAP_FMAC4 soap_in__ns1__verifBornePerso(struct soap *soap, const char *tag, _ns1__verifBornePerso *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__verifBornePerso *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__verifBornePerso, sizeof(_ns1__verifBornePerso), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__verifBornePerso)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__verifBornePerso *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Idenditifiant1 = 1;
	size_t soap_flag_MotDePasseMD51 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Idenditifiant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Idenditifiant", &(a->_ns1__verifBornePerso::Idenditifiant), "xsd:string"))
				{	soap_flag_Idenditifiant1--;
					continue;
				}
			if (soap_flag_MotDePasseMD51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MotDePasseMD5", &(a->_ns1__verifBornePerso::MotDePasseMD5), "xsd:string"))
				{	soap_flag_MotDePasseMD51--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__verifBornePerso *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__verifBornePerso, 0, sizeof(_ns1__verifBornePerso), 0, soap_copy__ns1__verifBornePerso);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Idenditifiant1 > 0 || soap_flag_MotDePasseMD51 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__verifBornePerso::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__verifBornePerso);
	if (this->soap_out(soap, tag?tag:"ns1:verifBornePerso", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__verifBornePerso::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__verifBornePerso(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__verifBornePerso * SOAP_FMAC4 soap_get__ns1__verifBornePerso(struct soap *soap, _ns1__verifBornePerso *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__verifBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__verifBornePerso * SOAP_FMAC2 soap_instantiate__ns1__verifBornePerso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__verifBornePerso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__verifBornePerso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__verifBornePerso);
		if (size)
			*size = sizeof(_ns1__verifBornePerso);
		((_ns1__verifBornePerso*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__verifBornePerso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__verifBornePerso);
		for (int i = 0; i < n; i++)
			((_ns1__verifBornePerso*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__verifBornePerso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__verifBornePerso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__verifBornePerso %p -> %p\n", q, p));
	*(_ns1__verifBornePerso*)p = *(_ns1__verifBornePerso*)q;
}

void _ns1__createBornePersoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__createBornePersoResponse::createBornePersoReturn);
	/* transient soap skipped */
}

void _ns1__createBornePersoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__createBornePersoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__createBornePersoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createBornePersoResponse(struct soap *soap, const char *tag, int id, const _ns1__createBornePersoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createBornePersoResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:createBornePersoReturn");
	if (soap_out_int(soap, "ns1:createBornePersoReturn", -1, &(a->_ns1__createBornePersoResponse::createBornePersoReturn), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__createBornePersoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__createBornePersoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__createBornePersoResponse * SOAP_FMAC4 soap_in__ns1__createBornePersoResponse(struct soap *soap, const char *tag, _ns1__createBornePersoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__createBornePersoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createBornePersoResponse, sizeof(_ns1__createBornePersoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__createBornePersoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__createBornePersoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_createBornePersoReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_createBornePersoReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:createBornePersoReturn", &(a->_ns1__createBornePersoResponse::createBornePersoReturn), "xsd:int"))
				{	soap_flag_createBornePersoReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:createBornePersoReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__createBornePersoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createBornePersoResponse, 0, sizeof(_ns1__createBornePersoResponse), 0, soap_copy__ns1__createBornePersoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_createBornePersoReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__createBornePersoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__createBornePersoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:createBornePersoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__createBornePersoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__createBornePersoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__createBornePersoResponse * SOAP_FMAC4 soap_get__ns1__createBornePersoResponse(struct soap *soap, _ns1__createBornePersoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createBornePersoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__createBornePersoResponse * SOAP_FMAC2 soap_instantiate__ns1__createBornePersoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__createBornePersoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__createBornePersoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__createBornePersoResponse);
		if (size)
			*size = sizeof(_ns1__createBornePersoResponse);
		((_ns1__createBornePersoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__createBornePersoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__createBornePersoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__createBornePersoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__createBornePersoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__createBornePersoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__createBornePersoResponse %p -> %p\n", q, p));
	*(_ns1__createBornePersoResponse*)p = *(_ns1__createBornePersoResponse*)q;
}

void _ns1__createBornePerso::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__createBornePerso::Idenditifiant);
	soap_default_string(soap, &this->_ns1__createBornePerso::MotDePasseMD5);
	/* transient soap skipped */
}

void _ns1__createBornePerso::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__createBornePerso::Idenditifiant);
	soap_serialize_string(soap, &this->_ns1__createBornePerso::MotDePasseMD5);
	/* transient soap skipped */
}

int _ns1__createBornePerso::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__createBornePerso(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createBornePerso(struct soap *soap, const char *tag, int id, const _ns1__createBornePerso *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createBornePerso), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Idenditifiant", -1, &(a->_ns1__createBornePerso::Idenditifiant), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MotDePasseMD5", -1, &(a->_ns1__createBornePerso::MotDePasseMD5), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__createBornePerso::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__createBornePerso(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__createBornePerso * SOAP_FMAC4 soap_in__ns1__createBornePerso(struct soap *soap, const char *tag, _ns1__createBornePerso *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__createBornePerso *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createBornePerso, sizeof(_ns1__createBornePerso), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__createBornePerso)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__createBornePerso *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Idenditifiant1 = 1;
	size_t soap_flag_MotDePasseMD51 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Idenditifiant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Idenditifiant", &(a->_ns1__createBornePerso::Idenditifiant), "xsd:string"))
				{	soap_flag_Idenditifiant1--;
					continue;
				}
			if (soap_flag_MotDePasseMD51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MotDePasseMD5", &(a->_ns1__createBornePerso::MotDePasseMD5), "xsd:string"))
				{	soap_flag_MotDePasseMD51--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__createBornePerso *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createBornePerso, 0, sizeof(_ns1__createBornePerso), 0, soap_copy__ns1__createBornePerso);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Idenditifiant1 > 0 || soap_flag_MotDePasseMD51 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__createBornePerso::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__createBornePerso);
	if (this->soap_out(soap, tag?tag:"ns1:createBornePerso", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__createBornePerso::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__createBornePerso(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__createBornePerso * SOAP_FMAC4 soap_get__ns1__createBornePerso(struct soap *soap, _ns1__createBornePerso *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__createBornePerso * SOAP_FMAC2 soap_instantiate__ns1__createBornePerso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__createBornePerso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__createBornePerso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__createBornePerso);
		if (size)
			*size = sizeof(_ns1__createBornePerso);
		((_ns1__createBornePerso*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__createBornePerso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__createBornePerso);
		for (int i = 0; i < n; i++)
			((_ns1__createBornePerso*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__createBornePerso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__createBornePerso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__createBornePerso %p -> %p\n", q, p));
	*(_ns1__createBornePerso*)p = *(_ns1__createBornePerso*)q;
}

void _ns1__deleteLigneStationBornePersoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__deleteLigneStationBornePersoResponse::deleteLigneStationBornePersoReturn);
	/* transient soap skipped */
}

void _ns1__deleteLigneStationBornePersoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__deleteLigneStationBornePersoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__deleteLigneStationBornePersoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__deleteLigneStationBornePersoResponse(struct soap *soap, const char *tag, int id, const _ns1__deleteLigneStationBornePersoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:deleteLigneStationBornePersoReturn");
	if (soap_out_int(soap, "ns1:deleteLigneStationBornePersoReturn", -1, &(a->_ns1__deleteLigneStationBornePersoResponse::deleteLigneStationBornePersoReturn), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__deleteLigneStationBornePersoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__deleteLigneStationBornePersoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__deleteLigneStationBornePersoResponse * SOAP_FMAC4 soap_in__ns1__deleteLigneStationBornePersoResponse(struct soap *soap, const char *tag, _ns1__deleteLigneStationBornePersoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__deleteLigneStationBornePersoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse, sizeof(_ns1__deleteLigneStationBornePersoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__deleteLigneStationBornePersoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_deleteLigneStationBornePersoReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deleteLigneStationBornePersoReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:deleteLigneStationBornePersoReturn", &(a->_ns1__deleteLigneStationBornePersoResponse::deleteLigneStationBornePersoReturn), "xsd:int"))
				{	soap_flag_deleteLigneStationBornePersoReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:deleteLigneStationBornePersoReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__deleteLigneStationBornePersoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse, 0, sizeof(_ns1__deleteLigneStationBornePersoResponse), 0, soap_copy__ns1__deleteLigneStationBornePersoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deleteLigneStationBornePersoReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__deleteLigneStationBornePersoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteLigneStationBornePersoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__deleteLigneStationBornePersoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__deleteLigneStationBornePersoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__deleteLigneStationBornePersoResponse * SOAP_FMAC4 soap_get__ns1__deleteLigneStationBornePersoResponse(struct soap *soap, _ns1__deleteLigneStationBornePersoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__deleteLigneStationBornePersoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__deleteLigneStationBornePersoResponse * SOAP_FMAC2 soap_instantiate__ns1__deleteLigneStationBornePersoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__deleteLigneStationBornePersoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__deleteLigneStationBornePersoResponse);
		if (size)
			*size = sizeof(_ns1__deleteLigneStationBornePersoResponse);
		((_ns1__deleteLigneStationBornePersoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__deleteLigneStationBornePersoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__deleteLigneStationBornePersoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__deleteLigneStationBornePersoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__deleteLigneStationBornePersoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__deleteLigneStationBornePersoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__deleteLigneStationBornePersoResponse %p -> %p\n", q, p));
	*(_ns1__deleteLigneStationBornePersoResponse*)p = *(_ns1__deleteLigneStationBornePersoResponse*)q;
}

void _ns1__deleteLigneStationBornePerso::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__deleteLigneStationBornePerso::Idenditifiant);
	soap_default_string(soap, &this->_ns1__deleteLigneStationBornePerso::MotDePasseMD5);
	soap_default_string(soap, &this->_ns1__deleteLigneStationBornePerso::nomStation);
	soap_default_string(soap, &this->_ns1__deleteLigneStationBornePerso::ligne);
	soap_default_string(soap, &this->_ns1__deleteLigneStationBornePerso::sens);
	/* transient soap skipped */
}

void _ns1__deleteLigneStationBornePerso::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__deleteLigneStationBornePerso::Idenditifiant);
	soap_serialize_string(soap, &this->_ns1__deleteLigneStationBornePerso::MotDePasseMD5);
	soap_serialize_string(soap, &this->_ns1__deleteLigneStationBornePerso::nomStation);
	soap_serialize_string(soap, &this->_ns1__deleteLigneStationBornePerso::ligne);
	soap_serialize_string(soap, &this->_ns1__deleteLigneStationBornePerso::sens);
	/* transient soap skipped */
}

int _ns1__deleteLigneStationBornePerso::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__deleteLigneStationBornePerso(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__deleteLigneStationBornePerso(struct soap *soap, const char *tag, int id, const _ns1__deleteLigneStationBornePerso *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__deleteLigneStationBornePerso), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Idenditifiant", -1, &(a->_ns1__deleteLigneStationBornePerso::Idenditifiant), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MotDePasseMD5", -1, &(a->_ns1__deleteLigneStationBornePerso::MotDePasseMD5), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:nomStation", -1, &(a->_ns1__deleteLigneStationBornePerso::nomStation), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ligne", -1, &(a->_ns1__deleteLigneStationBornePerso::ligne), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sens", -1, &(a->_ns1__deleteLigneStationBornePerso::sens), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__deleteLigneStationBornePerso::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__deleteLigneStationBornePerso(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__deleteLigneStationBornePerso * SOAP_FMAC4 soap_in__ns1__deleteLigneStationBornePerso(struct soap *soap, const char *tag, _ns1__deleteLigneStationBornePerso *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__deleteLigneStationBornePerso *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__deleteLigneStationBornePerso, sizeof(_ns1__deleteLigneStationBornePerso), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__deleteLigneStationBornePerso)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__deleteLigneStationBornePerso *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Idenditifiant1 = 1;
	size_t soap_flag_MotDePasseMD51 = 1;
	size_t soap_flag_nomStation1 = 1;
	size_t soap_flag_ligne1 = 1;
	size_t soap_flag_sens1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Idenditifiant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Idenditifiant", &(a->_ns1__deleteLigneStationBornePerso::Idenditifiant), "xsd:string"))
				{	soap_flag_Idenditifiant1--;
					continue;
				}
			if (soap_flag_MotDePasseMD51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MotDePasseMD5", &(a->_ns1__deleteLigneStationBornePerso::MotDePasseMD5), "xsd:string"))
				{	soap_flag_MotDePasseMD51--;
					continue;
				}
			if (soap_flag_nomStation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nomStation", &(a->_ns1__deleteLigneStationBornePerso::nomStation), "xsd:string"))
				{	soap_flag_nomStation1--;
					continue;
				}
			if (soap_flag_ligne1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ligne", &(a->_ns1__deleteLigneStationBornePerso::ligne), "xsd:string"))
				{	soap_flag_ligne1--;
					continue;
				}
			if (soap_flag_sens1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sens", &(a->_ns1__deleteLigneStationBornePerso::sens), "xsd:string"))
				{	soap_flag_sens1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__deleteLigneStationBornePerso *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__deleteLigneStationBornePerso, 0, sizeof(_ns1__deleteLigneStationBornePerso), 0, soap_copy__ns1__deleteLigneStationBornePerso);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Idenditifiant1 > 0 || soap_flag_MotDePasseMD51 > 0 || soap_flag_nomStation1 > 0 || soap_flag_ligne1 > 0 || soap_flag_sens1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__deleteLigneStationBornePerso::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__deleteLigneStationBornePerso);
	if (this->soap_out(soap, tag?tag:"ns1:deleteLigneStationBornePerso", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__deleteLigneStationBornePerso::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__deleteLigneStationBornePerso(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__deleteLigneStationBornePerso * SOAP_FMAC4 soap_get__ns1__deleteLigneStationBornePerso(struct soap *soap, _ns1__deleteLigneStationBornePerso *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__deleteLigneStationBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__deleteLigneStationBornePerso * SOAP_FMAC2 soap_instantiate__ns1__deleteLigneStationBornePerso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__deleteLigneStationBornePerso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__deleteLigneStationBornePerso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__deleteLigneStationBornePerso);
		if (size)
			*size = sizeof(_ns1__deleteLigneStationBornePerso);
		((_ns1__deleteLigneStationBornePerso*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__deleteLigneStationBornePerso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__deleteLigneStationBornePerso);
		for (int i = 0; i < n; i++)
			((_ns1__deleteLigneStationBornePerso*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__deleteLigneStationBornePerso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__deleteLigneStationBornePerso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__deleteLigneStationBornePerso %p -> %p\n", q, p));
	*(_ns1__deleteLigneStationBornePerso*)p = *(_ns1__deleteLigneStationBornePerso*)q;
}

void _ns1__addLigneStationBornePersoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__addLigneStationBornePersoResponse::addLigneStationBornePersoReturn);
	/* transient soap skipped */
}

void _ns1__addLigneStationBornePersoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__addLigneStationBornePersoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addLigneStationBornePersoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addLigneStationBornePersoResponse(struct soap *soap, const char *tag, int id, const _ns1__addLigneStationBornePersoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addLigneStationBornePersoResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:addLigneStationBornePersoReturn");
	if (soap_out_int(soap, "ns1:addLigneStationBornePersoReturn", -1, &(a->_ns1__addLigneStationBornePersoResponse::addLigneStationBornePersoReturn), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addLigneStationBornePersoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addLigneStationBornePersoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addLigneStationBornePersoResponse * SOAP_FMAC4 soap_in__ns1__addLigneStationBornePersoResponse(struct soap *soap, const char *tag, _ns1__addLigneStationBornePersoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addLigneStationBornePersoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addLigneStationBornePersoResponse, sizeof(_ns1__addLigneStationBornePersoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addLigneStationBornePersoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addLigneStationBornePersoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_addLigneStationBornePersoReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_addLigneStationBornePersoReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:addLigneStationBornePersoReturn", &(a->_ns1__addLigneStationBornePersoResponse::addLigneStationBornePersoReturn), "xsd:int"))
				{	soap_flag_addLigneStationBornePersoReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:addLigneStationBornePersoReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addLigneStationBornePersoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addLigneStationBornePersoResponse, 0, sizeof(_ns1__addLigneStationBornePersoResponse), 0, soap_copy__ns1__addLigneStationBornePersoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_addLigneStationBornePersoReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addLigneStationBornePersoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addLigneStationBornePersoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addLigneStationBornePersoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addLigneStationBornePersoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addLigneStationBornePersoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addLigneStationBornePersoResponse * SOAP_FMAC4 soap_get__ns1__addLigneStationBornePersoResponse(struct soap *soap, _ns1__addLigneStationBornePersoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addLigneStationBornePersoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addLigneStationBornePersoResponse * SOAP_FMAC2 soap_instantiate__ns1__addLigneStationBornePersoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addLigneStationBornePersoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addLigneStationBornePersoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__addLigneStationBornePersoResponse);
		if (size)
			*size = sizeof(_ns1__addLigneStationBornePersoResponse);
		((_ns1__addLigneStationBornePersoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__addLigneStationBornePersoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addLigneStationBornePersoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addLigneStationBornePersoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addLigneStationBornePersoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addLigneStationBornePersoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addLigneStationBornePersoResponse %p -> %p\n", q, p));
	*(_ns1__addLigneStationBornePersoResponse*)p = *(_ns1__addLigneStationBornePersoResponse*)q;
}

void _ns1__addLigneStationBornePerso::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__addLigneStationBornePerso::Idenditifiant);
	soap_default_string(soap, &this->_ns1__addLigneStationBornePerso::MotDePasseMD5);
	soap_default_string(soap, &this->_ns1__addLigneStationBornePerso::nomStation);
	soap_default_string(soap, &this->_ns1__addLigneStationBornePerso::ligne);
	soap_default_string(soap, &this->_ns1__addLigneStationBornePerso::sens);
	/* transient soap skipped */
}

void _ns1__addLigneStationBornePerso::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__addLigneStationBornePerso::Idenditifiant);
	soap_serialize_string(soap, &this->_ns1__addLigneStationBornePerso::MotDePasseMD5);
	soap_serialize_string(soap, &this->_ns1__addLigneStationBornePerso::nomStation);
	soap_serialize_string(soap, &this->_ns1__addLigneStationBornePerso::ligne);
	soap_serialize_string(soap, &this->_ns1__addLigneStationBornePerso::sens);
	/* transient soap skipped */
}

int _ns1__addLigneStationBornePerso::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addLigneStationBornePerso(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addLigneStationBornePerso(struct soap *soap, const char *tag, int id, const _ns1__addLigneStationBornePerso *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addLigneStationBornePerso), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Idenditifiant", -1, &(a->_ns1__addLigneStationBornePerso::Idenditifiant), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MotDePasseMD5", -1, &(a->_ns1__addLigneStationBornePerso::MotDePasseMD5), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:nomStation", -1, &(a->_ns1__addLigneStationBornePerso::nomStation), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ligne", -1, &(a->_ns1__addLigneStationBornePerso::ligne), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sens", -1, &(a->_ns1__addLigneStationBornePerso::sens), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addLigneStationBornePerso::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addLigneStationBornePerso(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addLigneStationBornePerso * SOAP_FMAC4 soap_in__ns1__addLigneStationBornePerso(struct soap *soap, const char *tag, _ns1__addLigneStationBornePerso *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addLigneStationBornePerso *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addLigneStationBornePerso, sizeof(_ns1__addLigneStationBornePerso), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addLigneStationBornePerso)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addLigneStationBornePerso *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Idenditifiant1 = 1;
	size_t soap_flag_MotDePasseMD51 = 1;
	size_t soap_flag_nomStation1 = 1;
	size_t soap_flag_ligne1 = 1;
	size_t soap_flag_sens1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Idenditifiant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Idenditifiant", &(a->_ns1__addLigneStationBornePerso::Idenditifiant), "xsd:string"))
				{	soap_flag_Idenditifiant1--;
					continue;
				}
			if (soap_flag_MotDePasseMD51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MotDePasseMD5", &(a->_ns1__addLigneStationBornePerso::MotDePasseMD5), "xsd:string"))
				{	soap_flag_MotDePasseMD51--;
					continue;
				}
			if (soap_flag_nomStation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nomStation", &(a->_ns1__addLigneStationBornePerso::nomStation), "xsd:string"))
				{	soap_flag_nomStation1--;
					continue;
				}
			if (soap_flag_ligne1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ligne", &(a->_ns1__addLigneStationBornePerso::ligne), "xsd:string"))
				{	soap_flag_ligne1--;
					continue;
				}
			if (soap_flag_sens1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sens", &(a->_ns1__addLigneStationBornePerso::sens), "xsd:string"))
				{	soap_flag_sens1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addLigneStationBornePerso *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addLigneStationBornePerso, 0, sizeof(_ns1__addLigneStationBornePerso), 0, soap_copy__ns1__addLigneStationBornePerso);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Idenditifiant1 > 0 || soap_flag_MotDePasseMD51 > 0 || soap_flag_nomStation1 > 0 || soap_flag_ligne1 > 0 || soap_flag_sens1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addLigneStationBornePerso::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addLigneStationBornePerso);
	if (this->soap_out(soap, tag?tag:"ns1:addLigneStationBornePerso", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addLigneStationBornePerso::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addLigneStationBornePerso(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addLigneStationBornePerso * SOAP_FMAC4 soap_get__ns1__addLigneStationBornePerso(struct soap *soap, _ns1__addLigneStationBornePerso *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addLigneStationBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addLigneStationBornePerso * SOAP_FMAC2 soap_instantiate__ns1__addLigneStationBornePerso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addLigneStationBornePerso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addLigneStationBornePerso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__addLigneStationBornePerso);
		if (size)
			*size = sizeof(_ns1__addLigneStationBornePerso);
		((_ns1__addLigneStationBornePerso*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__addLigneStationBornePerso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addLigneStationBornePerso);
		for (int i = 0; i < n; i++)
			((_ns1__addLigneStationBornePerso*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addLigneStationBornePerso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addLigneStationBornePerso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addLigneStationBornePerso %p -> %p\n", q, p));
	*(_ns1__addLigneStationBornePerso*)p = *(_ns1__addLigneStationBornePerso*)q;
}

void _ns1__getLigneStationBornePersoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getLigneStationBornePersoResponse::__sizegetLigneStationBornePersoReturn = 0;
	this->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getLigneStationBornePersoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn)
	{	int i;
		for (i = 0; i < this->_ns1__getLigneStationBornePersoResponse::__sizegetLigneStationBornePersoReturn; i++)
		{
			soap_serialize_string(soap, this->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getLigneStationBornePersoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getLigneStationBornePersoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getLigneStationBornePersoResponse(struct soap *soap, const char *tag, int id, const _ns1__getLigneStationBornePersoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getLigneStationBornePersoResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizegetLigneStationBornePersoReturn");
	if (a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn)
	{	int i;
		for (i = 0; i < a->_ns1__getLigneStationBornePersoResponse::__sizegetLigneStationBornePersoReturn; i++)
			if (soap_out_string(soap, "ns1:getLigneStationBornePersoReturn", -1, a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getLigneStationBornePersoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getLigneStationBornePersoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getLigneStationBornePersoResponse * SOAP_FMAC4 soap_in__ns1__getLigneStationBornePersoResponse(struct soap *soap, const char *tag, _ns1__getLigneStationBornePersoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getLigneStationBornePersoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getLigneStationBornePersoResponse, sizeof(_ns1__getLigneStationBornePersoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getLigneStationBornePersoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getLigneStationBornePersoResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_getLigneStationBornePersoReturn1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:getLigneStationBornePersoReturn", 1, NULL))
			{	if (a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn == NULL)
				{	if (soap_blist_getLigneStationBornePersoReturn1 == NULL)
						soap_blist_getLigneStationBornePersoReturn1 = soap_new_block(soap);
					a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn = (char **)soap_push_block(soap, soap_blist_getLigneStationBornePersoReturn1, sizeof(char *));
					if (a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn == NULL)
						return NULL;
					*a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns1:getLigneStationBornePersoReturn", a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn, "xsd:string"))
				{	a->_ns1__getLigneStationBornePersoResponse::__sizegetLigneStationBornePersoReturn++;
					a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizegetLigneStationBornePersoReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn)
			soap_pop_block(soap, soap_blist_getLigneStationBornePersoReturn1);
		if (a->_ns1__getLigneStationBornePersoResponse::__sizegetLigneStationBornePersoReturn)
			a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn = (char **)soap_save_block(soap, soap_blist_getLigneStationBornePersoReturn1, NULL, 1);
		else
		{	a->_ns1__getLigneStationBornePersoResponse::getLigneStationBornePersoReturn = NULL;
			if (soap_blist_getLigneStationBornePersoReturn1)
				soap_end_block(soap, soap_blist_getLigneStationBornePersoReturn1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getLigneStationBornePersoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getLigneStationBornePersoResponse, 0, sizeof(_ns1__getLigneStationBornePersoResponse), 0, soap_copy__ns1__getLigneStationBornePersoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getLigneStationBornePersoResponse::__sizegetLigneStationBornePersoReturn < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getLigneStationBornePersoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getLigneStationBornePersoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getLigneStationBornePersoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getLigneStationBornePersoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getLigneStationBornePersoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getLigneStationBornePersoResponse * SOAP_FMAC4 soap_get__ns1__getLigneStationBornePersoResponse(struct soap *soap, _ns1__getLigneStationBornePersoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getLigneStationBornePersoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getLigneStationBornePersoResponse * SOAP_FMAC2 soap_instantiate__ns1__getLigneStationBornePersoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getLigneStationBornePersoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getLigneStationBornePersoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getLigneStationBornePersoResponse);
		if (size)
			*size = sizeof(_ns1__getLigneStationBornePersoResponse);
		((_ns1__getLigneStationBornePersoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getLigneStationBornePersoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getLigneStationBornePersoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getLigneStationBornePersoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getLigneStationBornePersoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getLigneStationBornePersoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getLigneStationBornePersoResponse %p -> %p\n", q, p));
	*(_ns1__getLigneStationBornePersoResponse*)p = *(_ns1__getLigneStationBornePersoResponse*)q;
}

void _ns1__getLigneStationBornePerso::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getLigneStationBornePerso::Idenditifiant);
	soap_default_string(soap, &this->_ns1__getLigneStationBornePerso::MotDePasseMD5);
	/* transient soap skipped */
}

void _ns1__getLigneStationBornePerso::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getLigneStationBornePerso::Idenditifiant);
	soap_serialize_string(soap, &this->_ns1__getLigneStationBornePerso::MotDePasseMD5);
	/* transient soap skipped */
}

int _ns1__getLigneStationBornePerso::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getLigneStationBornePerso(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getLigneStationBornePerso(struct soap *soap, const char *tag, int id, const _ns1__getLigneStationBornePerso *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getLigneStationBornePerso), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Idenditifiant", -1, &(a->_ns1__getLigneStationBornePerso::Idenditifiant), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MotDePasseMD5", -1, &(a->_ns1__getLigneStationBornePerso::MotDePasseMD5), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getLigneStationBornePerso::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getLigneStationBornePerso(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getLigneStationBornePerso * SOAP_FMAC4 soap_in__ns1__getLigneStationBornePerso(struct soap *soap, const char *tag, _ns1__getLigneStationBornePerso *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getLigneStationBornePerso *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getLigneStationBornePerso, sizeof(_ns1__getLigneStationBornePerso), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getLigneStationBornePerso)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getLigneStationBornePerso *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Idenditifiant1 = 1;
	size_t soap_flag_MotDePasseMD51 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Idenditifiant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Idenditifiant", &(a->_ns1__getLigneStationBornePerso::Idenditifiant), "xsd:string"))
				{	soap_flag_Idenditifiant1--;
					continue;
				}
			if (soap_flag_MotDePasseMD51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MotDePasseMD5", &(a->_ns1__getLigneStationBornePerso::MotDePasseMD5), "xsd:string"))
				{	soap_flag_MotDePasseMD51--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getLigneStationBornePerso *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getLigneStationBornePerso, 0, sizeof(_ns1__getLigneStationBornePerso), 0, soap_copy__ns1__getLigneStationBornePerso);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Idenditifiant1 > 0 || soap_flag_MotDePasseMD51 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getLigneStationBornePerso::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getLigneStationBornePerso);
	if (this->soap_out(soap, tag?tag:"ns1:getLigneStationBornePerso", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getLigneStationBornePerso::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getLigneStationBornePerso(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getLigneStationBornePerso * SOAP_FMAC4 soap_get__ns1__getLigneStationBornePerso(struct soap *soap, _ns1__getLigneStationBornePerso *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getLigneStationBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getLigneStationBornePerso * SOAP_FMAC2 soap_instantiate__ns1__getLigneStationBornePerso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getLigneStationBornePerso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getLigneStationBornePerso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getLigneStationBornePerso);
		if (size)
			*size = sizeof(_ns1__getLigneStationBornePerso);
		((_ns1__getLigneStationBornePerso*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getLigneStationBornePerso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getLigneStationBornePerso);
		for (int i = 0; i < n; i++)
			((_ns1__getLigneStationBornePerso*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getLigneStationBornePerso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getLigneStationBornePerso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getLigneStationBornePerso %p -> %p\n", q, p));
	*(_ns1__getLigneStationBornePerso*)p = *(_ns1__getLigneStationBornePerso*)q;
}

void _ns1__getInfoTraficResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getInfoTraficResponse::__sizegetInfoTraficReturn = 0;
	this->_ns1__getInfoTraficResponse::getInfoTraficReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getInfoTraficResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getInfoTraficResponse::getInfoTraficReturn)
	{	int i;
		for (i = 0; i < this->_ns1__getInfoTraficResponse::__sizegetInfoTraficReturn; i++)
		{
			soap_serialize_string(soap, this->_ns1__getInfoTraficResponse::getInfoTraficReturn + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getInfoTraficResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getInfoTraficResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getInfoTraficResponse(struct soap *soap, const char *tag, int id, const _ns1__getInfoTraficResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getInfoTraficResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizegetInfoTraficReturn");
	if (a->_ns1__getInfoTraficResponse::getInfoTraficReturn)
	{	int i;
		for (i = 0; i < a->_ns1__getInfoTraficResponse::__sizegetInfoTraficReturn; i++)
			if (soap_out_string(soap, "ns1:getInfoTraficReturn", -1, a->_ns1__getInfoTraficResponse::getInfoTraficReturn + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getInfoTraficResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getInfoTraficResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getInfoTraficResponse * SOAP_FMAC4 soap_in__ns1__getInfoTraficResponse(struct soap *soap, const char *tag, _ns1__getInfoTraficResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getInfoTraficResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getInfoTraficResponse, sizeof(_ns1__getInfoTraficResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getInfoTraficResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getInfoTraficResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_getInfoTraficReturn1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:getInfoTraficReturn", 1, NULL))
			{	if (a->_ns1__getInfoTraficResponse::getInfoTraficReturn == NULL)
				{	if (soap_blist_getInfoTraficReturn1 == NULL)
						soap_blist_getInfoTraficReturn1 = soap_new_block(soap);
					a->_ns1__getInfoTraficResponse::getInfoTraficReturn = (char **)soap_push_block(soap, soap_blist_getInfoTraficReturn1, sizeof(char *));
					if (a->_ns1__getInfoTraficResponse::getInfoTraficReturn == NULL)
						return NULL;
					*a->_ns1__getInfoTraficResponse::getInfoTraficReturn = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns1:getInfoTraficReturn", a->_ns1__getInfoTraficResponse::getInfoTraficReturn, "xsd:string"))
				{	a->_ns1__getInfoTraficResponse::__sizegetInfoTraficReturn++;
					a->_ns1__getInfoTraficResponse::getInfoTraficReturn = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizegetInfoTraficReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getInfoTraficResponse::getInfoTraficReturn)
			soap_pop_block(soap, soap_blist_getInfoTraficReturn1);
		if (a->_ns1__getInfoTraficResponse::__sizegetInfoTraficReturn)
			a->_ns1__getInfoTraficResponse::getInfoTraficReturn = (char **)soap_save_block(soap, soap_blist_getInfoTraficReturn1, NULL, 1);
		else
		{	a->_ns1__getInfoTraficResponse::getInfoTraficReturn = NULL;
			if (soap_blist_getInfoTraficReturn1)
				soap_end_block(soap, soap_blist_getInfoTraficReturn1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getInfoTraficResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getInfoTraficResponse, 0, sizeof(_ns1__getInfoTraficResponse), 0, soap_copy__ns1__getInfoTraficResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getInfoTraficResponse::__sizegetInfoTraficReturn < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getInfoTraficResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getInfoTraficResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getInfoTraficResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getInfoTraficResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getInfoTraficResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getInfoTraficResponse * SOAP_FMAC4 soap_get__ns1__getInfoTraficResponse(struct soap *soap, _ns1__getInfoTraficResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getInfoTraficResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getInfoTraficResponse * SOAP_FMAC2 soap_instantiate__ns1__getInfoTraficResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getInfoTraficResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getInfoTraficResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getInfoTraficResponse);
		if (size)
			*size = sizeof(_ns1__getInfoTraficResponse);
		((_ns1__getInfoTraficResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getInfoTraficResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getInfoTraficResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getInfoTraficResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getInfoTraficResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getInfoTraficResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getInfoTraficResponse %p -> %p\n", q, p));
	*(_ns1__getInfoTraficResponse*)p = *(_ns1__getInfoTraficResponse*)q;
}

void _ns1__getInfoTrafic::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getInfoTrafic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__getInfoTrafic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getInfoTrafic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getInfoTrafic(struct soap *soap, const char *tag, int id, const _ns1__getInfoTrafic *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getInfoTrafic), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getInfoTrafic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getInfoTrafic(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getInfoTrafic * SOAP_FMAC4 soap_in__ns1__getInfoTrafic(struct soap *soap, const char *tag, _ns1__getInfoTrafic *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getInfoTrafic *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getInfoTrafic, sizeof(_ns1__getInfoTrafic), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getInfoTrafic)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getInfoTrafic *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getInfoTrafic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getInfoTrafic, 0, sizeof(_ns1__getInfoTrafic), 0, soap_copy__ns1__getInfoTrafic);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__getInfoTrafic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getInfoTrafic);
	if (this->soap_out(soap, tag?tag:"ns1:getInfoTrafic", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getInfoTrafic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getInfoTrafic(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getInfoTrafic * SOAP_FMAC4 soap_get__ns1__getInfoTrafic(struct soap *soap, _ns1__getInfoTrafic *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getInfoTrafic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getInfoTrafic * SOAP_FMAC2 soap_instantiate__ns1__getInfoTrafic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getInfoTrafic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getInfoTrafic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getInfoTrafic);
		if (size)
			*size = sizeof(_ns1__getInfoTrafic);
		((_ns1__getInfoTrafic*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getInfoTrafic[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getInfoTrafic);
		for (int i = 0; i < n; i++)
			((_ns1__getInfoTrafic*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getInfoTrafic*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getInfoTrafic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getInfoTrafic %p -> %p\n", q, p));
	*(_ns1__getInfoTrafic*)p = *(_ns1__getInfoTrafic*)q;
}

void _ns1__getTempsParStationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getTempsParStationResponse::__sizegetTempsParStationReturn = 0;
	this->_ns1__getTempsParStationResponse::getTempsParStationReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getTempsParStationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getTempsParStationResponse::getTempsParStationReturn)
	{	int i;
		for (i = 0; i < this->_ns1__getTempsParStationResponse::__sizegetTempsParStationReturn; i++)
		{
			soap_serialize_string(soap, this->_ns1__getTempsParStationResponse::getTempsParStationReturn + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getTempsParStationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTempsParStationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTempsParStationResponse(struct soap *soap, const char *tag, int id, const _ns1__getTempsParStationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTempsParStationResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizegetTempsParStationReturn");
	if (a->_ns1__getTempsParStationResponse::getTempsParStationReturn)
	{	int i;
		for (i = 0; i < a->_ns1__getTempsParStationResponse::__sizegetTempsParStationReturn; i++)
			if (soap_out_string(soap, "ns1:getTempsParStationReturn", -1, a->_ns1__getTempsParStationResponse::getTempsParStationReturn + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTempsParStationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTempsParStationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTempsParStationResponse * SOAP_FMAC4 soap_in__ns1__getTempsParStationResponse(struct soap *soap, const char *tag, _ns1__getTempsParStationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTempsParStationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTempsParStationResponse, sizeof(_ns1__getTempsParStationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTempsParStationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTempsParStationResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_getTempsParStationReturn1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:getTempsParStationReturn", 1, NULL))
			{	if (a->_ns1__getTempsParStationResponse::getTempsParStationReturn == NULL)
				{	if (soap_blist_getTempsParStationReturn1 == NULL)
						soap_blist_getTempsParStationReturn1 = soap_new_block(soap);
					a->_ns1__getTempsParStationResponse::getTempsParStationReturn = (char **)soap_push_block(soap, soap_blist_getTempsParStationReturn1, sizeof(char *));
					if (a->_ns1__getTempsParStationResponse::getTempsParStationReturn == NULL)
						return NULL;
					*a->_ns1__getTempsParStationResponse::getTempsParStationReturn = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns1:getTempsParStationReturn", a->_ns1__getTempsParStationResponse::getTempsParStationReturn, "xsd:string"))
				{	a->_ns1__getTempsParStationResponse::__sizegetTempsParStationReturn++;
					a->_ns1__getTempsParStationResponse::getTempsParStationReturn = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizegetTempsParStationReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getTempsParStationResponse::getTempsParStationReturn)
			soap_pop_block(soap, soap_blist_getTempsParStationReturn1);
		if (a->_ns1__getTempsParStationResponse::__sizegetTempsParStationReturn)
			a->_ns1__getTempsParStationResponse::getTempsParStationReturn = (char **)soap_save_block(soap, soap_blist_getTempsParStationReturn1, NULL, 1);
		else
		{	a->_ns1__getTempsParStationResponse::getTempsParStationReturn = NULL;
			if (soap_blist_getTempsParStationReturn1)
				soap_end_block(soap, soap_blist_getTempsParStationReturn1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTempsParStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTempsParStationResponse, 0, sizeof(_ns1__getTempsParStationResponse), 0, soap_copy__ns1__getTempsParStationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getTempsParStationResponse::__sizegetTempsParStationReturn < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTempsParStationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTempsParStationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTempsParStationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTempsParStationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTempsParStationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTempsParStationResponse * SOAP_FMAC4 soap_get__ns1__getTempsParStationResponse(struct soap *soap, _ns1__getTempsParStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTempsParStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTempsParStationResponse * SOAP_FMAC2 soap_instantiate__ns1__getTempsParStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTempsParStationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTempsParStationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getTempsParStationResponse);
		if (size)
			*size = sizeof(_ns1__getTempsParStationResponse);
		((_ns1__getTempsParStationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getTempsParStationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTempsParStationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTempsParStationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTempsParStationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTempsParStationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTempsParStationResponse %p -> %p\n", q, p));
	*(_ns1__getTempsParStationResponse*)p = *(_ns1__getTempsParStationResponse*)q;
}

void _ns1__getTempsParStation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getTempsParStation::nomStation);
	/* transient soap skipped */
}

void _ns1__getTempsParStation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getTempsParStation::nomStation);
	/* transient soap skipped */
}

int _ns1__getTempsParStation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTempsParStation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTempsParStation(struct soap *soap, const char *tag, int id, const _ns1__getTempsParStation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTempsParStation), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:nomStation", -1, &(a->_ns1__getTempsParStation::nomStation), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTempsParStation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTempsParStation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTempsParStation * SOAP_FMAC4 soap_in__ns1__getTempsParStation(struct soap *soap, const char *tag, _ns1__getTempsParStation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTempsParStation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTempsParStation, sizeof(_ns1__getTempsParStation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTempsParStation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTempsParStation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nomStation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nomStation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nomStation", &(a->_ns1__getTempsParStation::nomStation), "xsd:string"))
				{	soap_flag_nomStation1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTempsParStation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTempsParStation, 0, sizeof(_ns1__getTempsParStation), 0, soap_copy__ns1__getTempsParStation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nomStation1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTempsParStation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTempsParStation);
	if (this->soap_out(soap, tag?tag:"ns1:getTempsParStation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTempsParStation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTempsParStation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTempsParStation * SOAP_FMAC4 soap_get__ns1__getTempsParStation(struct soap *soap, _ns1__getTempsParStation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTempsParStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTempsParStation * SOAP_FMAC2 soap_instantiate__ns1__getTempsParStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTempsParStation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTempsParStation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getTempsParStation);
		if (size)
			*size = sizeof(_ns1__getTempsParStation);
		((_ns1__getTempsParStation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getTempsParStation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTempsParStation);
		for (int i = 0; i < n; i++)
			((_ns1__getTempsParStation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTempsParStation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTempsParStation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTempsParStation %p -> %p\n", q, p));
	*(_ns1__getTempsParStation*)p = *(_ns1__getTempsParStation*)q;
}

void _ns1__getListeStationsProchesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getListeStationsProchesResponse::__sizegetListeStationsProchesReturn = 0;
	this->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getListeStationsProchesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn)
	{	int i;
		for (i = 0; i < this->_ns1__getListeStationsProchesResponse::__sizegetListeStationsProchesReturn; i++)
		{
			soap_serialize_string(soap, this->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getListeStationsProchesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getListeStationsProchesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getListeStationsProchesResponse(struct soap *soap, const char *tag, int id, const _ns1__getListeStationsProchesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getListeStationsProchesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizegetListeStationsProchesReturn");
	if (a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn)
	{	int i;
		for (i = 0; i < a->_ns1__getListeStationsProchesResponse::__sizegetListeStationsProchesReturn; i++)
			if (soap_out_string(soap, "ns1:getListeStationsProchesReturn", -1, a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getListeStationsProchesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getListeStationsProchesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getListeStationsProchesResponse * SOAP_FMAC4 soap_in__ns1__getListeStationsProchesResponse(struct soap *soap, const char *tag, _ns1__getListeStationsProchesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getListeStationsProchesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getListeStationsProchesResponse, sizeof(_ns1__getListeStationsProchesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getListeStationsProchesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getListeStationsProchesResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_getListeStationsProchesReturn1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:getListeStationsProchesReturn", 1, NULL))
			{	if (a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn == NULL)
				{	if (soap_blist_getListeStationsProchesReturn1 == NULL)
						soap_blist_getListeStationsProchesReturn1 = soap_new_block(soap);
					a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn = (char **)soap_push_block(soap, soap_blist_getListeStationsProchesReturn1, sizeof(char *));
					if (a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn == NULL)
						return NULL;
					*a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns1:getListeStationsProchesReturn", a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn, "xsd:string"))
				{	a->_ns1__getListeStationsProchesResponse::__sizegetListeStationsProchesReturn++;
					a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizegetListeStationsProchesReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn)
			soap_pop_block(soap, soap_blist_getListeStationsProchesReturn1);
		if (a->_ns1__getListeStationsProchesResponse::__sizegetListeStationsProchesReturn)
			a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn = (char **)soap_save_block(soap, soap_blist_getListeStationsProchesReturn1, NULL, 1);
		else
		{	a->_ns1__getListeStationsProchesResponse::getListeStationsProchesReturn = NULL;
			if (soap_blist_getListeStationsProchesReturn1)
				soap_end_block(soap, soap_blist_getListeStationsProchesReturn1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getListeStationsProchesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getListeStationsProchesResponse, 0, sizeof(_ns1__getListeStationsProchesResponse), 0, soap_copy__ns1__getListeStationsProchesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getListeStationsProchesResponse::__sizegetListeStationsProchesReturn < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getListeStationsProchesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getListeStationsProchesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getListeStationsProchesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getListeStationsProchesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getListeStationsProchesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getListeStationsProchesResponse * SOAP_FMAC4 soap_get__ns1__getListeStationsProchesResponse(struct soap *soap, _ns1__getListeStationsProchesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getListeStationsProchesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getListeStationsProchesResponse * SOAP_FMAC2 soap_instantiate__ns1__getListeStationsProchesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getListeStationsProchesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getListeStationsProchesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getListeStationsProchesResponse);
		if (size)
			*size = sizeof(_ns1__getListeStationsProchesResponse);
		((_ns1__getListeStationsProchesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getListeStationsProchesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getListeStationsProchesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getListeStationsProchesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getListeStationsProchesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getListeStationsProchesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getListeStationsProchesResponse %p -> %p\n", q, p));
	*(_ns1__getListeStationsProchesResponse*)p = *(_ns1__getListeStationsProchesResponse*)q;
}

void _ns1__getListeStationsProches::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getListeStationsProches::Longitute);
	soap_default_string(soap, &this->_ns1__getListeStationsProches::Latitude);
	soap_default_float(soap, &this->_ns1__getListeStationsProches::precision);
	/* transient soap skipped */
}

void _ns1__getListeStationsProches::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getListeStationsProches::Longitute);
	soap_serialize_string(soap, &this->_ns1__getListeStationsProches::Latitude);
	/* transient soap skipped */
}

int _ns1__getListeStationsProches::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getListeStationsProches(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getListeStationsProches(struct soap *soap, const char *tag, int id, const _ns1__getListeStationsProches *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getListeStationsProches), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Longitute", -1, &(a->_ns1__getListeStationsProches::Longitute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Latitude", -1, &(a->_ns1__getListeStationsProches::Latitude), ""))
		return soap->error;
	if (soap_out_float(soap, "ns1:precision", -1, &(a->_ns1__getListeStationsProches::precision), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getListeStationsProches::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getListeStationsProches(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getListeStationsProches * SOAP_FMAC4 soap_in__ns1__getListeStationsProches(struct soap *soap, const char *tag, _ns1__getListeStationsProches *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getListeStationsProches *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getListeStationsProches, sizeof(_ns1__getListeStationsProches), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getListeStationsProches)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getListeStationsProches *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Longitute1 = 1;
	size_t soap_flag_Latitude1 = 1;
	size_t soap_flag_precision1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Longitute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Longitute", &(a->_ns1__getListeStationsProches::Longitute), "xsd:string"))
				{	soap_flag_Longitute1--;
					continue;
				}
			if (soap_flag_Latitude1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Latitude", &(a->_ns1__getListeStationsProches::Latitude), "xsd:string"))
				{	soap_flag_Latitude1--;
					continue;
				}
			if (soap_flag_precision1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns1:precision", &(a->_ns1__getListeStationsProches::precision), "xsd:float"))
				{	soap_flag_precision1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getListeStationsProches *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getListeStationsProches, 0, sizeof(_ns1__getListeStationsProches), 0, soap_copy__ns1__getListeStationsProches);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Longitute1 > 0 || soap_flag_Latitude1 > 0 || soap_flag_precision1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getListeStationsProches::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getListeStationsProches);
	if (this->soap_out(soap, tag?tag:"ns1:getListeStationsProches", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getListeStationsProches::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getListeStationsProches(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getListeStationsProches * SOAP_FMAC4 soap_get__ns1__getListeStationsProches(struct soap *soap, _ns1__getListeStationsProches *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getListeStationsProches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getListeStationsProches * SOAP_FMAC2 soap_instantiate__ns1__getListeStationsProches(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getListeStationsProches(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getListeStationsProches, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getListeStationsProches);
		if (size)
			*size = sizeof(_ns1__getListeStationsProches);
		((_ns1__getListeStationsProches*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getListeStationsProches[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getListeStationsProches);
		for (int i = 0; i < n; i++)
			((_ns1__getListeStationsProches*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getListeStationsProches*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getListeStationsProches(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getListeStationsProches %p -> %p\n", q, p));
	*(_ns1__getListeStationsProches*)p = *(_ns1__getListeStationsProches*)q;
}

void _ns1__getListeStationsParLigneResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getListeStationsParLigneResponse::__sizegetListeStationsParLigneReturn = 0;
	this->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getListeStationsParLigneResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn)
	{	int i;
		for (i = 0; i < this->_ns1__getListeStationsParLigneResponse::__sizegetListeStationsParLigneReturn; i++)
		{
			soap_serialize_string(soap, this->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getListeStationsParLigneResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getListeStationsParLigneResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getListeStationsParLigneResponse(struct soap *soap, const char *tag, int id, const _ns1__getListeStationsParLigneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getListeStationsParLigneResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizegetListeStationsParLigneReturn");
	if (a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn)
	{	int i;
		for (i = 0; i < a->_ns1__getListeStationsParLigneResponse::__sizegetListeStationsParLigneReturn; i++)
			if (soap_out_string(soap, "ns1:getListeStationsParLigneReturn", -1, a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getListeStationsParLigneResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getListeStationsParLigneResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getListeStationsParLigneResponse * SOAP_FMAC4 soap_in__ns1__getListeStationsParLigneResponse(struct soap *soap, const char *tag, _ns1__getListeStationsParLigneResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getListeStationsParLigneResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getListeStationsParLigneResponse, sizeof(_ns1__getListeStationsParLigneResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getListeStationsParLigneResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getListeStationsParLigneResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_getListeStationsParLigneReturn1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:getListeStationsParLigneReturn", 1, NULL))
			{	if (a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn == NULL)
				{	if (soap_blist_getListeStationsParLigneReturn1 == NULL)
						soap_blist_getListeStationsParLigneReturn1 = soap_new_block(soap);
					a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn = (char **)soap_push_block(soap, soap_blist_getListeStationsParLigneReturn1, sizeof(char *));
					if (a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn == NULL)
						return NULL;
					*a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns1:getListeStationsParLigneReturn", a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn, "xsd:string"))
				{	a->_ns1__getListeStationsParLigneResponse::__sizegetListeStationsParLigneReturn++;
					a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizegetListeStationsParLigneReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn)
			soap_pop_block(soap, soap_blist_getListeStationsParLigneReturn1);
		if (a->_ns1__getListeStationsParLigneResponse::__sizegetListeStationsParLigneReturn)
			a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn = (char **)soap_save_block(soap, soap_blist_getListeStationsParLigneReturn1, NULL, 1);
		else
		{	a->_ns1__getListeStationsParLigneResponse::getListeStationsParLigneReturn = NULL;
			if (soap_blist_getListeStationsParLigneReturn1)
				soap_end_block(soap, soap_blist_getListeStationsParLigneReturn1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getListeStationsParLigneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getListeStationsParLigneResponse, 0, sizeof(_ns1__getListeStationsParLigneResponse), 0, soap_copy__ns1__getListeStationsParLigneResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getListeStationsParLigneResponse::__sizegetListeStationsParLigneReturn < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getListeStationsParLigneResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getListeStationsParLigneResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getListeStationsParLigneResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getListeStationsParLigneResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getListeStationsParLigneResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getListeStationsParLigneResponse * SOAP_FMAC4 soap_get__ns1__getListeStationsParLigneResponse(struct soap *soap, _ns1__getListeStationsParLigneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getListeStationsParLigneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getListeStationsParLigneResponse * SOAP_FMAC2 soap_instantiate__ns1__getListeStationsParLigneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getListeStationsParLigneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getListeStationsParLigneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getListeStationsParLigneResponse);
		if (size)
			*size = sizeof(_ns1__getListeStationsParLigneResponse);
		((_ns1__getListeStationsParLigneResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getListeStationsParLigneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getListeStationsParLigneResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getListeStationsParLigneResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getListeStationsParLigneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getListeStationsParLigneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getListeStationsParLigneResponse %p -> %p\n", q, p));
	*(_ns1__getListeStationsParLigneResponse*)p = *(_ns1__getListeStationsParLigneResponse*)q;
}

void _ns1__getListeStationsParLigne::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getListeStationsParLigne::ligne);
	soap_default_string(soap, &this->_ns1__getListeStationsParLigne::sens);
	/* transient soap skipped */
}

void _ns1__getListeStationsParLigne::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getListeStationsParLigne::ligne);
	soap_serialize_string(soap, &this->_ns1__getListeStationsParLigne::sens);
	/* transient soap skipped */
}

int _ns1__getListeStationsParLigne::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getListeStationsParLigne(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getListeStationsParLigne(struct soap *soap, const char *tag, int id, const _ns1__getListeStationsParLigne *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getListeStationsParLigne), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:ligne", -1, &(a->_ns1__getListeStationsParLigne::ligne), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sens", -1, &(a->_ns1__getListeStationsParLigne::sens), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getListeStationsParLigne::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getListeStationsParLigne(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getListeStationsParLigne * SOAP_FMAC4 soap_in__ns1__getListeStationsParLigne(struct soap *soap, const char *tag, _ns1__getListeStationsParLigne *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getListeStationsParLigne *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getListeStationsParLigne, sizeof(_ns1__getListeStationsParLigne), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getListeStationsParLigne)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getListeStationsParLigne *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ligne1 = 1;
	size_t soap_flag_sens1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ligne1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ligne", &(a->_ns1__getListeStationsParLigne::ligne), "xsd:string"))
				{	soap_flag_ligne1--;
					continue;
				}
			if (soap_flag_sens1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sens", &(a->_ns1__getListeStationsParLigne::sens), "xsd:string"))
				{	soap_flag_sens1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getListeStationsParLigne *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getListeStationsParLigne, 0, sizeof(_ns1__getListeStationsParLigne), 0, soap_copy__ns1__getListeStationsParLigne);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ligne1 > 0 || soap_flag_sens1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getListeStationsParLigne::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getListeStationsParLigne);
	if (this->soap_out(soap, tag?tag:"ns1:getListeStationsParLigne", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getListeStationsParLigne::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getListeStationsParLigne(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getListeStationsParLigne * SOAP_FMAC4 soap_get__ns1__getListeStationsParLigne(struct soap *soap, _ns1__getListeStationsParLigne *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getListeStationsParLigne(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getListeStationsParLigne * SOAP_FMAC2 soap_instantiate__ns1__getListeStationsParLigne(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getListeStationsParLigne(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getListeStationsParLigne, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getListeStationsParLigne);
		if (size)
			*size = sizeof(_ns1__getListeStationsParLigne);
		((_ns1__getListeStationsParLigne*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getListeStationsParLigne[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getListeStationsParLigne);
		for (int i = 0; i < n; i++)
			((_ns1__getListeStationsParLigne*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getListeStationsParLigne*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getListeStationsParLigne(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getListeStationsParLigne %p -> %p\n", q, p));
	*(_ns1__getListeStationsParLigne*)p = *(_ns1__getListeStationsParLigne*)q;
}

void _ns1__getListeStationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getListeStationsResponse::__sizegetListeStationsReturn = 0;
	this->_ns1__getListeStationsResponse::getListeStationsReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getListeStationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getListeStationsResponse::getListeStationsReturn)
	{	int i;
		for (i = 0; i < this->_ns1__getListeStationsResponse::__sizegetListeStationsReturn; i++)
		{
			soap_serialize_string(soap, this->_ns1__getListeStationsResponse::getListeStationsReturn + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getListeStationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getListeStationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getListeStationsResponse(struct soap *soap, const char *tag, int id, const _ns1__getListeStationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getListeStationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizegetListeStationsReturn");
	if (a->_ns1__getListeStationsResponse::getListeStationsReturn)
	{	int i;
		for (i = 0; i < a->_ns1__getListeStationsResponse::__sizegetListeStationsReturn; i++)
			if (soap_out_string(soap, "ns1:getListeStationsReturn", -1, a->_ns1__getListeStationsResponse::getListeStationsReturn + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getListeStationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getListeStationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getListeStationsResponse * SOAP_FMAC4 soap_in__ns1__getListeStationsResponse(struct soap *soap, const char *tag, _ns1__getListeStationsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getListeStationsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getListeStationsResponse, sizeof(_ns1__getListeStationsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getListeStationsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getListeStationsResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_getListeStationsReturn1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:getListeStationsReturn", 1, NULL))
			{	if (a->_ns1__getListeStationsResponse::getListeStationsReturn == NULL)
				{	if (soap_blist_getListeStationsReturn1 == NULL)
						soap_blist_getListeStationsReturn1 = soap_new_block(soap);
					a->_ns1__getListeStationsResponse::getListeStationsReturn = (char **)soap_push_block(soap, soap_blist_getListeStationsReturn1, sizeof(char *));
					if (a->_ns1__getListeStationsResponse::getListeStationsReturn == NULL)
						return NULL;
					*a->_ns1__getListeStationsResponse::getListeStationsReturn = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns1:getListeStationsReturn", a->_ns1__getListeStationsResponse::getListeStationsReturn, "xsd:string"))
				{	a->_ns1__getListeStationsResponse::__sizegetListeStationsReturn++;
					a->_ns1__getListeStationsResponse::getListeStationsReturn = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizegetListeStationsReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getListeStationsResponse::getListeStationsReturn)
			soap_pop_block(soap, soap_blist_getListeStationsReturn1);
		if (a->_ns1__getListeStationsResponse::__sizegetListeStationsReturn)
			a->_ns1__getListeStationsResponse::getListeStationsReturn = (char **)soap_save_block(soap, soap_blist_getListeStationsReturn1, NULL, 1);
		else
		{	a->_ns1__getListeStationsResponse::getListeStationsReturn = NULL;
			if (soap_blist_getListeStationsReturn1)
				soap_end_block(soap, soap_blist_getListeStationsReturn1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getListeStationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getListeStationsResponse, 0, sizeof(_ns1__getListeStationsResponse), 0, soap_copy__ns1__getListeStationsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getListeStationsResponse::__sizegetListeStationsReturn < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getListeStationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getListeStationsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getListeStationsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getListeStationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getListeStationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getListeStationsResponse * SOAP_FMAC4 soap_get__ns1__getListeStationsResponse(struct soap *soap, _ns1__getListeStationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getListeStationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getListeStationsResponse * SOAP_FMAC2 soap_instantiate__ns1__getListeStationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getListeStationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getListeStationsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getListeStationsResponse);
		if (size)
			*size = sizeof(_ns1__getListeStationsResponse);
		((_ns1__getListeStationsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getListeStationsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getListeStationsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getListeStationsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getListeStationsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getListeStationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getListeStationsResponse %p -> %p\n", q, p));
	*(_ns1__getListeStationsResponse*)p = *(_ns1__getListeStationsResponse*)q;
}

void _ns1__getListeStations::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getListeStations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__getListeStations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getListeStations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getListeStations(struct soap *soap, const char *tag, int id, const _ns1__getListeStations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getListeStations), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getListeStations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getListeStations(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getListeStations * SOAP_FMAC4 soap_in__ns1__getListeStations(struct soap *soap, const char *tag, _ns1__getListeStations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getListeStations *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getListeStations, sizeof(_ns1__getListeStations), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getListeStations)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getListeStations *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getListeStations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getListeStations, 0, sizeof(_ns1__getListeStations), 0, soap_copy__ns1__getListeStations);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__getListeStations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getListeStations);
	if (this->soap_out(soap, tag?tag:"ns1:getListeStations", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getListeStations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getListeStations(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getListeStations * SOAP_FMAC4 soap_get__ns1__getListeStations(struct soap *soap, _ns1__getListeStations *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getListeStations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getListeStations * SOAP_FMAC2 soap_instantiate__ns1__getListeStations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getListeStations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getListeStations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getListeStations);
		if (size)
			*size = sizeof(_ns1__getListeStations);
		((_ns1__getListeStations*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getListeStations[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getListeStations);
		for (int i = 0; i < n; i++)
			((_ns1__getListeStations*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getListeStations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getListeStations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getListeStations %p -> %p\n", q, p));
	*(_ns1__getListeStations*)p = *(_ns1__getListeStations*)q;
}

void _ns1__getListeLignesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getListeLignesResponse::__sizegetListeLignesReturn = 0;
	this->_ns1__getListeLignesResponse::getListeLignesReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getListeLignesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getListeLignesResponse::getListeLignesReturn)
	{	int i;
		for (i = 0; i < this->_ns1__getListeLignesResponse::__sizegetListeLignesReturn; i++)
		{
			soap_serialize_string(soap, this->_ns1__getListeLignesResponse::getListeLignesReturn + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getListeLignesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getListeLignesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getListeLignesResponse(struct soap *soap, const char *tag, int id, const _ns1__getListeLignesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getListeLignesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizegetListeLignesReturn");
	if (a->_ns1__getListeLignesResponse::getListeLignesReturn)
	{	int i;
		for (i = 0; i < a->_ns1__getListeLignesResponse::__sizegetListeLignesReturn; i++)
			if (soap_out_string(soap, "ns1:getListeLignesReturn", -1, a->_ns1__getListeLignesResponse::getListeLignesReturn + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getListeLignesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getListeLignesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getListeLignesResponse * SOAP_FMAC4 soap_in__ns1__getListeLignesResponse(struct soap *soap, const char *tag, _ns1__getListeLignesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getListeLignesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getListeLignesResponse, sizeof(_ns1__getListeLignesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getListeLignesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getListeLignesResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_getListeLignesReturn1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:getListeLignesReturn", 1, NULL))
			{	if (a->_ns1__getListeLignesResponse::getListeLignesReturn == NULL)
				{	if (soap_blist_getListeLignesReturn1 == NULL)
						soap_blist_getListeLignesReturn1 = soap_new_block(soap);
					a->_ns1__getListeLignesResponse::getListeLignesReturn = (char **)soap_push_block(soap, soap_blist_getListeLignesReturn1, sizeof(char *));
					if (a->_ns1__getListeLignesResponse::getListeLignesReturn == NULL)
						return NULL;
					*a->_ns1__getListeLignesResponse::getListeLignesReturn = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns1:getListeLignesReturn", a->_ns1__getListeLignesResponse::getListeLignesReturn, "xsd:string"))
				{	a->_ns1__getListeLignesResponse::__sizegetListeLignesReturn++;
					a->_ns1__getListeLignesResponse::getListeLignesReturn = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizegetListeLignesReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getListeLignesResponse::getListeLignesReturn)
			soap_pop_block(soap, soap_blist_getListeLignesReturn1);
		if (a->_ns1__getListeLignesResponse::__sizegetListeLignesReturn)
			a->_ns1__getListeLignesResponse::getListeLignesReturn = (char **)soap_save_block(soap, soap_blist_getListeLignesReturn1, NULL, 1);
		else
		{	a->_ns1__getListeLignesResponse::getListeLignesReturn = NULL;
			if (soap_blist_getListeLignesReturn1)
				soap_end_block(soap, soap_blist_getListeLignesReturn1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getListeLignesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getListeLignesResponse, 0, sizeof(_ns1__getListeLignesResponse), 0, soap_copy__ns1__getListeLignesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getListeLignesResponse::__sizegetListeLignesReturn < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getListeLignesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getListeLignesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getListeLignesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getListeLignesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getListeLignesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getListeLignesResponse * SOAP_FMAC4 soap_get__ns1__getListeLignesResponse(struct soap *soap, _ns1__getListeLignesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getListeLignesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getListeLignesResponse * SOAP_FMAC2 soap_instantiate__ns1__getListeLignesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getListeLignesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getListeLignesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getListeLignesResponse);
		if (size)
			*size = sizeof(_ns1__getListeLignesResponse);
		((_ns1__getListeLignesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getListeLignesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getListeLignesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getListeLignesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getListeLignesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getListeLignesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getListeLignesResponse %p -> %p\n", q, p));
	*(_ns1__getListeLignesResponse*)p = *(_ns1__getListeLignesResponse*)q;
}

void _ns1__getListeLignes::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getListeLignes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__getListeLignes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getListeLignes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getListeLignes(struct soap *soap, const char *tag, int id, const _ns1__getListeLignes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getListeLignes), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getListeLignes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getListeLignes(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getListeLignes * SOAP_FMAC4 soap_in__ns1__getListeLignes(struct soap *soap, const char *tag, _ns1__getListeLignes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getListeLignes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getListeLignes, sizeof(_ns1__getListeLignes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getListeLignes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getListeLignes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getListeLignes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getListeLignes, 0, sizeof(_ns1__getListeLignes), 0, soap_copy__ns1__getListeLignes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__getListeLignes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getListeLignes);
	if (this->soap_out(soap, tag?tag:"ns1:getListeLignes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getListeLignes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getListeLignes(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getListeLignes * SOAP_FMAC4 soap_get__ns1__getListeLignes(struct soap *soap, _ns1__getListeLignes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getListeLignes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getListeLignes * SOAP_FMAC2 soap_instantiate__ns1__getListeLignes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getListeLignes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getListeLignes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getListeLignes);
		if (size)
			*size = sizeof(_ns1__getListeLignes);
		((_ns1__getListeLignes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getListeLignes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getListeLignes);
		for (int i = 0; i < n; i++)
			((_ns1__getListeLignes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getListeLignes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getListeLignes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getListeLignes %p -> %p\n", q, p));
	*(_ns1__getListeLignes*)p = *(_ns1__getListeLignes*)q;
}

void _ns1__getMessagesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getMessagesResponse::__sizegetMessagesReturn = 0;
	this->_ns1__getMessagesResponse::getMessagesReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getMessagesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getMessagesResponse::getMessagesReturn)
	{	int i;
		for (i = 0; i < this->_ns1__getMessagesResponse::__sizegetMessagesReturn; i++)
		{
			soap_serialize_string(soap, this->_ns1__getMessagesResponse::getMessagesReturn + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getMessagesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMessagesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMessagesResponse(struct soap *soap, const char *tag, int id, const _ns1__getMessagesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizegetMessagesReturn");
	if (a->_ns1__getMessagesResponse::getMessagesReturn)
	{	int i;
		for (i = 0; i < a->_ns1__getMessagesResponse::__sizegetMessagesReturn; i++)
			if (soap_out_string(soap, "ns1:getMessagesReturn", -1, a->_ns1__getMessagesResponse::getMessagesReturn + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMessagesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMessagesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMessagesResponse * SOAP_FMAC4 soap_in__ns1__getMessagesResponse(struct soap *soap, const char *tag, _ns1__getMessagesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMessagesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMessagesResponse, sizeof(_ns1__getMessagesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getMessagesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getMessagesResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_getMessagesReturn1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:getMessagesReturn", 1, NULL))
			{	if (a->_ns1__getMessagesResponse::getMessagesReturn == NULL)
				{	if (soap_blist_getMessagesReturn1 == NULL)
						soap_blist_getMessagesReturn1 = soap_new_block(soap);
					a->_ns1__getMessagesResponse::getMessagesReturn = (char **)soap_push_block(soap, soap_blist_getMessagesReturn1, sizeof(char *));
					if (a->_ns1__getMessagesResponse::getMessagesReturn == NULL)
						return NULL;
					*a->_ns1__getMessagesResponse::getMessagesReturn = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns1:getMessagesReturn", a->_ns1__getMessagesResponse::getMessagesReturn, "xsd:string"))
				{	a->_ns1__getMessagesResponse::__sizegetMessagesReturn++;
					a->_ns1__getMessagesResponse::getMessagesReturn = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizegetMessagesReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getMessagesResponse::getMessagesReturn)
			soap_pop_block(soap, soap_blist_getMessagesReturn1);
		if (a->_ns1__getMessagesResponse::__sizegetMessagesReturn)
			a->_ns1__getMessagesResponse::getMessagesReturn = (char **)soap_save_block(soap, soap_blist_getMessagesReturn1, NULL, 1);
		else
		{	a->_ns1__getMessagesResponse::getMessagesReturn = NULL;
			if (soap_blist_getMessagesReturn1)
				soap_end_block(soap, soap_blist_getMessagesReturn1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMessagesResponse, 0, sizeof(_ns1__getMessagesResponse), 0, soap_copy__ns1__getMessagesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getMessagesResponse::__sizegetMessagesReturn < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getMessagesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getMessagesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getMessagesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMessagesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMessagesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMessagesResponse * SOAP_FMAC4 soap_get__ns1__getMessagesResponse(struct soap *soap, _ns1__getMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getMessagesResponse * SOAP_FMAC2 soap_instantiate__ns1__getMessagesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMessagesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getMessagesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getMessagesResponse);
		if (size)
			*size = sizeof(_ns1__getMessagesResponse);
		((_ns1__getMessagesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getMessagesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getMessagesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getMessagesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getMessagesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getMessagesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getMessagesResponse %p -> %p\n", q, p));
	*(_ns1__getMessagesResponse*)p = *(_ns1__getMessagesResponse*)q;
}

void _ns1__getMessages::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getMessages::listeIdMessage);
	/* transient soap skipped */
}

void _ns1__getMessages::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getMessages::listeIdMessage);
	/* transient soap skipped */
}

int _ns1__getMessages::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMessages(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMessages(struct soap *soap, const char *tag, int id, const _ns1__getMessages *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMessages), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:listeIdMessage", -1, &(a->_ns1__getMessages::listeIdMessage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMessages::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMessages(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMessages * SOAP_FMAC4 soap_in__ns1__getMessages(struct soap *soap, const char *tag, _ns1__getMessages *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMessages *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMessages, sizeof(_ns1__getMessages), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getMessages)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getMessages *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_listeIdMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_listeIdMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:listeIdMessage", &(a->_ns1__getMessages::listeIdMessage), "xsd:string"))
				{	soap_flag_listeIdMessage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMessages, 0, sizeof(_ns1__getMessages), 0, soap_copy__ns1__getMessages);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_listeIdMessage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getMessages::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getMessages);
	if (this->soap_out(soap, tag?tag:"ns1:getMessages", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMessages::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMessages(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMessages * SOAP_FMAC4 soap_get__ns1__getMessages(struct soap *soap, _ns1__getMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getMessages * SOAP_FMAC2 soap_instantiate__ns1__getMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMessages(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getMessages, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_ns1__getMessages);
		if (size)
			*size = sizeof(_ns1__getMessages);
		((_ns1__getMessages*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_ns1__getMessages[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getMessages);
		for (int i = 0; i < n; i++)
			((_ns1__getMessages*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getMessages*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getMessages(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getMessages %p -> %p\n", q, p));
	*(_ns1__getMessages*)p = *(_ns1__getMessages*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__verifBornePerso(struct soap *soap, struct __ns1__verifBornePerso *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__verifBornePerso = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__verifBornePerso(struct soap *soap, const struct __ns1__verifBornePerso *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__verifBornePerso(soap, &a->ns1__verifBornePerso);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__verifBornePerso(struct soap *soap, const char *tag, int id, const struct __ns1__verifBornePerso *a, const char *type)
{
	if (soap_out_PointerTo_ns1__verifBornePerso(soap, "ns1:verifBornePerso", -1, &a->ns1__verifBornePerso, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__verifBornePerso * SOAP_FMAC4 soap_in___ns1__verifBornePerso(struct soap *soap, const char *tag, struct __ns1__verifBornePerso *a, const char *type)
{
	size_t soap_flag_ns1__verifBornePerso = 1;
	short soap_flag;
	a = (struct __ns1__verifBornePerso *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__verifBornePerso, sizeof(struct __ns1__verifBornePerso), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__verifBornePerso(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__verifBornePerso && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__verifBornePerso(soap, "ns1:verifBornePerso", &a->ns1__verifBornePerso, ""))
				{	soap_flag_ns1__verifBornePerso--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__verifBornePerso(struct soap *soap, const struct __ns1__verifBornePerso *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__verifBornePerso(soap, tag?tag:"-ns1:verifBornePerso", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__verifBornePerso * SOAP_FMAC4 soap_get___ns1__verifBornePerso(struct soap *soap, struct __ns1__verifBornePerso *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__verifBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__verifBornePerso * SOAP_FMAC2 soap_instantiate___ns1__verifBornePerso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__verifBornePerso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__verifBornePerso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__verifBornePerso);
		if (size)
			*size = sizeof(struct __ns1__verifBornePerso);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__verifBornePerso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__verifBornePerso);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__verifBornePerso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__verifBornePerso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__verifBornePerso %p -> %p\n", q, p));
	*(struct __ns1__verifBornePerso*)p = *(struct __ns1__verifBornePerso*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createBornePerso(struct soap *soap, struct __ns1__createBornePerso *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createBornePerso = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createBornePerso(struct soap *soap, const struct __ns1__createBornePerso *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__createBornePerso(soap, &a->ns1__createBornePerso);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createBornePerso(struct soap *soap, const char *tag, int id, const struct __ns1__createBornePerso *a, const char *type)
{
	if (soap_out_PointerTo_ns1__createBornePerso(soap, "ns1:createBornePerso", -1, &a->ns1__createBornePerso, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createBornePerso * SOAP_FMAC4 soap_in___ns1__createBornePerso(struct soap *soap, const char *tag, struct __ns1__createBornePerso *a, const char *type)
{
	size_t soap_flag_ns1__createBornePerso = 1;
	short soap_flag;
	a = (struct __ns1__createBornePerso *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createBornePerso, sizeof(struct __ns1__createBornePerso), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createBornePerso(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createBornePerso && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__createBornePerso(soap, "ns1:createBornePerso", &a->ns1__createBornePerso, ""))
				{	soap_flag_ns1__createBornePerso--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createBornePerso(struct soap *soap, const struct __ns1__createBornePerso *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createBornePerso(soap, tag?tag:"-ns1:createBornePerso", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createBornePerso * SOAP_FMAC4 soap_get___ns1__createBornePerso(struct soap *soap, struct __ns1__createBornePerso *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__createBornePerso * SOAP_FMAC2 soap_instantiate___ns1__createBornePerso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createBornePerso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__createBornePerso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__createBornePerso);
		if (size)
			*size = sizeof(struct __ns1__createBornePerso);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__createBornePerso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__createBornePerso);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__createBornePerso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__createBornePerso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__createBornePerso %p -> %p\n", q, p));
	*(struct __ns1__createBornePerso*)p = *(struct __ns1__createBornePerso*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteLigneStationBornePerso(struct soap *soap, struct __ns1__deleteLigneStationBornePerso *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteLigneStationBornePerso = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteLigneStationBornePerso(struct soap *soap, const struct __ns1__deleteLigneStationBornePerso *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__deleteLigneStationBornePerso(soap, &a->ns1__deleteLigneStationBornePerso);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteLigneStationBornePerso(struct soap *soap, const char *tag, int id, const struct __ns1__deleteLigneStationBornePerso *a, const char *type)
{
	if (soap_out_PointerTo_ns1__deleteLigneStationBornePerso(soap, "ns1:deleteLigneStationBornePerso", -1, &a->ns1__deleteLigneStationBornePerso, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteLigneStationBornePerso * SOAP_FMAC4 soap_in___ns1__deleteLigneStationBornePerso(struct soap *soap, const char *tag, struct __ns1__deleteLigneStationBornePerso *a, const char *type)
{
	size_t soap_flag_ns1__deleteLigneStationBornePerso = 1;
	short soap_flag;
	a = (struct __ns1__deleteLigneStationBornePerso *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteLigneStationBornePerso, sizeof(struct __ns1__deleteLigneStationBornePerso), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteLigneStationBornePerso(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteLigneStationBornePerso && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__deleteLigneStationBornePerso(soap, "ns1:deleteLigneStationBornePerso", &a->ns1__deleteLigneStationBornePerso, ""))
				{	soap_flag_ns1__deleteLigneStationBornePerso--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteLigneStationBornePerso(struct soap *soap, const struct __ns1__deleteLigneStationBornePerso *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteLigneStationBornePerso(soap, tag?tag:"-ns1:deleteLigneStationBornePerso", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteLigneStationBornePerso * SOAP_FMAC4 soap_get___ns1__deleteLigneStationBornePerso(struct soap *soap, struct __ns1__deleteLigneStationBornePerso *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteLigneStationBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteLigneStationBornePerso * SOAP_FMAC2 soap_instantiate___ns1__deleteLigneStationBornePerso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteLigneStationBornePerso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteLigneStationBornePerso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__deleteLigneStationBornePerso);
		if (size)
			*size = sizeof(struct __ns1__deleteLigneStationBornePerso);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__deleteLigneStationBornePerso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteLigneStationBornePerso);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteLigneStationBornePerso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteLigneStationBornePerso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteLigneStationBornePerso %p -> %p\n", q, p));
	*(struct __ns1__deleteLigneStationBornePerso*)p = *(struct __ns1__deleteLigneStationBornePerso*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addLigneStationBornePerso(struct soap *soap, struct __ns1__addLigneStationBornePerso *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addLigneStationBornePerso = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addLigneStationBornePerso(struct soap *soap, const struct __ns1__addLigneStationBornePerso *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addLigneStationBornePerso(soap, &a->ns1__addLigneStationBornePerso);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addLigneStationBornePerso(struct soap *soap, const char *tag, int id, const struct __ns1__addLigneStationBornePerso *a, const char *type)
{
	if (soap_out_PointerTo_ns1__addLigneStationBornePerso(soap, "ns1:addLigneStationBornePerso", -1, &a->ns1__addLigneStationBornePerso, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addLigneStationBornePerso * SOAP_FMAC4 soap_in___ns1__addLigneStationBornePerso(struct soap *soap, const char *tag, struct __ns1__addLigneStationBornePerso *a, const char *type)
{
	size_t soap_flag_ns1__addLigneStationBornePerso = 1;
	short soap_flag;
	a = (struct __ns1__addLigneStationBornePerso *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addLigneStationBornePerso, sizeof(struct __ns1__addLigneStationBornePerso), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addLigneStationBornePerso(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addLigneStationBornePerso && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addLigneStationBornePerso(soap, "ns1:addLigneStationBornePerso", &a->ns1__addLigneStationBornePerso, ""))
				{	soap_flag_ns1__addLigneStationBornePerso--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addLigneStationBornePerso(struct soap *soap, const struct __ns1__addLigneStationBornePerso *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addLigneStationBornePerso(soap, tag?tag:"-ns1:addLigneStationBornePerso", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addLigneStationBornePerso * SOAP_FMAC4 soap_get___ns1__addLigneStationBornePerso(struct soap *soap, struct __ns1__addLigneStationBornePerso *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addLigneStationBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addLigneStationBornePerso * SOAP_FMAC2 soap_instantiate___ns1__addLigneStationBornePerso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addLigneStationBornePerso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addLigneStationBornePerso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__addLigneStationBornePerso);
		if (size)
			*size = sizeof(struct __ns1__addLigneStationBornePerso);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__addLigneStationBornePerso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addLigneStationBornePerso);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addLigneStationBornePerso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addLigneStationBornePerso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addLigneStationBornePerso %p -> %p\n", q, p));
	*(struct __ns1__addLigneStationBornePerso*)p = *(struct __ns1__addLigneStationBornePerso*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getLigneStationBornePerso(struct soap *soap, struct __ns1__getLigneStationBornePerso *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getLigneStationBornePerso = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getLigneStationBornePerso(struct soap *soap, const struct __ns1__getLigneStationBornePerso *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getLigneStationBornePerso(soap, &a->ns1__getLigneStationBornePerso);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getLigneStationBornePerso(struct soap *soap, const char *tag, int id, const struct __ns1__getLigneStationBornePerso *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getLigneStationBornePerso(soap, "ns1:getLigneStationBornePerso", -1, &a->ns1__getLigneStationBornePerso, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLigneStationBornePerso * SOAP_FMAC4 soap_in___ns1__getLigneStationBornePerso(struct soap *soap, const char *tag, struct __ns1__getLigneStationBornePerso *a, const char *type)
{
	size_t soap_flag_ns1__getLigneStationBornePerso = 1;
	short soap_flag;
	a = (struct __ns1__getLigneStationBornePerso *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getLigneStationBornePerso, sizeof(struct __ns1__getLigneStationBornePerso), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getLigneStationBornePerso(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getLigneStationBornePerso && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getLigneStationBornePerso(soap, "ns1:getLigneStationBornePerso", &a->ns1__getLigneStationBornePerso, ""))
				{	soap_flag_ns1__getLigneStationBornePerso--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getLigneStationBornePerso(struct soap *soap, const struct __ns1__getLigneStationBornePerso *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getLigneStationBornePerso(soap, tag?tag:"-ns1:getLigneStationBornePerso", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLigneStationBornePerso * SOAP_FMAC4 soap_get___ns1__getLigneStationBornePerso(struct soap *soap, struct __ns1__getLigneStationBornePerso *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getLigneStationBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getLigneStationBornePerso * SOAP_FMAC2 soap_instantiate___ns1__getLigneStationBornePerso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getLigneStationBornePerso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getLigneStationBornePerso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__getLigneStationBornePerso);
		if (size)
			*size = sizeof(struct __ns1__getLigneStationBornePerso);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__getLigneStationBornePerso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getLigneStationBornePerso);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getLigneStationBornePerso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getLigneStationBornePerso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getLigneStationBornePerso %p -> %p\n", q, p));
	*(struct __ns1__getLigneStationBornePerso*)p = *(struct __ns1__getLigneStationBornePerso*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getInfoTrafic(struct soap *soap, struct __ns1__getInfoTrafic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getInfoTrafic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getInfoTrafic(struct soap *soap, const struct __ns1__getInfoTrafic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getInfoTrafic(soap, &a->ns1__getInfoTrafic);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getInfoTrafic(struct soap *soap, const char *tag, int id, const struct __ns1__getInfoTrafic *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getInfoTrafic(soap, "ns1:getInfoTrafic", -1, &a->ns1__getInfoTrafic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInfoTrafic * SOAP_FMAC4 soap_in___ns1__getInfoTrafic(struct soap *soap, const char *tag, struct __ns1__getInfoTrafic *a, const char *type)
{
	size_t soap_flag_ns1__getInfoTrafic = 1;
	short soap_flag;
	a = (struct __ns1__getInfoTrafic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getInfoTrafic, sizeof(struct __ns1__getInfoTrafic), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getInfoTrafic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getInfoTrafic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getInfoTrafic(soap, "ns1:getInfoTrafic", &a->ns1__getInfoTrafic, ""))
				{	soap_flag_ns1__getInfoTrafic--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getInfoTrafic(struct soap *soap, const struct __ns1__getInfoTrafic *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getInfoTrafic(soap, tag?tag:"-ns1:getInfoTrafic", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInfoTrafic * SOAP_FMAC4 soap_get___ns1__getInfoTrafic(struct soap *soap, struct __ns1__getInfoTrafic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getInfoTrafic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getInfoTrafic * SOAP_FMAC2 soap_instantiate___ns1__getInfoTrafic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getInfoTrafic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getInfoTrafic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__getInfoTrafic);
		if (size)
			*size = sizeof(struct __ns1__getInfoTrafic);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__getInfoTrafic[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getInfoTrafic);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getInfoTrafic*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getInfoTrafic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getInfoTrafic %p -> %p\n", q, p));
	*(struct __ns1__getInfoTrafic*)p = *(struct __ns1__getInfoTrafic*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTempsParStation(struct soap *soap, struct __ns1__getTempsParStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTempsParStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTempsParStation(struct soap *soap, const struct __ns1__getTempsParStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTempsParStation(soap, &a->ns1__getTempsParStation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTempsParStation(struct soap *soap, const char *tag, int id, const struct __ns1__getTempsParStation *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getTempsParStation(soap, "ns1:getTempsParStation", -1, &a->ns1__getTempsParStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTempsParStation * SOAP_FMAC4 soap_in___ns1__getTempsParStation(struct soap *soap, const char *tag, struct __ns1__getTempsParStation *a, const char *type)
{
	size_t soap_flag_ns1__getTempsParStation = 1;
	short soap_flag;
	a = (struct __ns1__getTempsParStation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTempsParStation, sizeof(struct __ns1__getTempsParStation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTempsParStation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTempsParStation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTempsParStation(soap, "ns1:getTempsParStation", &a->ns1__getTempsParStation, ""))
				{	soap_flag_ns1__getTempsParStation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTempsParStation(struct soap *soap, const struct __ns1__getTempsParStation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTempsParStation(soap, tag?tag:"-ns1:getTempsParStation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTempsParStation * SOAP_FMAC4 soap_get___ns1__getTempsParStation(struct soap *soap, struct __ns1__getTempsParStation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTempsParStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTempsParStation * SOAP_FMAC2 soap_instantiate___ns1__getTempsParStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTempsParStation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTempsParStation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__getTempsParStation);
		if (size)
			*size = sizeof(struct __ns1__getTempsParStation);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__getTempsParStation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getTempsParStation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getTempsParStation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTempsParStation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTempsParStation %p -> %p\n", q, p));
	*(struct __ns1__getTempsParStation*)p = *(struct __ns1__getTempsParStation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getListeStationsProches(struct soap *soap, struct __ns1__getListeStationsProches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getListeStationsProches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getListeStationsProches(struct soap *soap, const struct __ns1__getListeStationsProches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getListeStationsProches(soap, &a->ns1__getListeStationsProches);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getListeStationsProches(struct soap *soap, const char *tag, int id, const struct __ns1__getListeStationsProches *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getListeStationsProches(soap, "ns1:getListeStationsProches", -1, &a->ns1__getListeStationsProches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getListeStationsProches * SOAP_FMAC4 soap_in___ns1__getListeStationsProches(struct soap *soap, const char *tag, struct __ns1__getListeStationsProches *a, const char *type)
{
	size_t soap_flag_ns1__getListeStationsProches = 1;
	short soap_flag;
	a = (struct __ns1__getListeStationsProches *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getListeStationsProches, sizeof(struct __ns1__getListeStationsProches), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getListeStationsProches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getListeStationsProches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getListeStationsProches(soap, "ns1:getListeStationsProches", &a->ns1__getListeStationsProches, ""))
				{	soap_flag_ns1__getListeStationsProches--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getListeStationsProches(struct soap *soap, const struct __ns1__getListeStationsProches *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getListeStationsProches(soap, tag?tag:"-ns1:getListeStationsProches", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getListeStationsProches * SOAP_FMAC4 soap_get___ns1__getListeStationsProches(struct soap *soap, struct __ns1__getListeStationsProches *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getListeStationsProches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getListeStationsProches * SOAP_FMAC2 soap_instantiate___ns1__getListeStationsProches(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getListeStationsProches(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getListeStationsProches, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__getListeStationsProches);
		if (size)
			*size = sizeof(struct __ns1__getListeStationsProches);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__getListeStationsProches[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getListeStationsProches);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getListeStationsProches*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getListeStationsProches(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getListeStationsProches %p -> %p\n", q, p));
	*(struct __ns1__getListeStationsProches*)p = *(struct __ns1__getListeStationsProches*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getListeStationsParLigne(struct soap *soap, struct __ns1__getListeStationsParLigne *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getListeStationsParLigne = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getListeStationsParLigne(struct soap *soap, const struct __ns1__getListeStationsParLigne *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getListeStationsParLigne(soap, &a->ns1__getListeStationsParLigne);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getListeStationsParLigne(struct soap *soap, const char *tag, int id, const struct __ns1__getListeStationsParLigne *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getListeStationsParLigne(soap, "ns1:getListeStationsParLigne", -1, &a->ns1__getListeStationsParLigne, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getListeStationsParLigne * SOAP_FMAC4 soap_in___ns1__getListeStationsParLigne(struct soap *soap, const char *tag, struct __ns1__getListeStationsParLigne *a, const char *type)
{
	size_t soap_flag_ns1__getListeStationsParLigne = 1;
	short soap_flag;
	a = (struct __ns1__getListeStationsParLigne *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getListeStationsParLigne, sizeof(struct __ns1__getListeStationsParLigne), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getListeStationsParLigne(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getListeStationsParLigne && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getListeStationsParLigne(soap, "ns1:getListeStationsParLigne", &a->ns1__getListeStationsParLigne, ""))
				{	soap_flag_ns1__getListeStationsParLigne--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getListeStationsParLigne(struct soap *soap, const struct __ns1__getListeStationsParLigne *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getListeStationsParLigne(soap, tag?tag:"-ns1:getListeStationsParLigne", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getListeStationsParLigne * SOAP_FMAC4 soap_get___ns1__getListeStationsParLigne(struct soap *soap, struct __ns1__getListeStationsParLigne *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getListeStationsParLigne(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getListeStationsParLigne * SOAP_FMAC2 soap_instantiate___ns1__getListeStationsParLigne(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getListeStationsParLigne(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getListeStationsParLigne, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__getListeStationsParLigne);
		if (size)
			*size = sizeof(struct __ns1__getListeStationsParLigne);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__getListeStationsParLigne[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getListeStationsParLigne);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getListeStationsParLigne*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getListeStationsParLigne(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getListeStationsParLigne %p -> %p\n", q, p));
	*(struct __ns1__getListeStationsParLigne*)p = *(struct __ns1__getListeStationsParLigne*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getListeStations(struct soap *soap, struct __ns1__getListeStations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getListeStations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getListeStations(struct soap *soap, const struct __ns1__getListeStations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getListeStations(soap, &a->ns1__getListeStations);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getListeStations(struct soap *soap, const char *tag, int id, const struct __ns1__getListeStations *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getListeStations(soap, "ns1:getListeStations", -1, &a->ns1__getListeStations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getListeStations * SOAP_FMAC4 soap_in___ns1__getListeStations(struct soap *soap, const char *tag, struct __ns1__getListeStations *a, const char *type)
{
	size_t soap_flag_ns1__getListeStations = 1;
	short soap_flag;
	a = (struct __ns1__getListeStations *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getListeStations, sizeof(struct __ns1__getListeStations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getListeStations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getListeStations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getListeStations(soap, "ns1:getListeStations", &a->ns1__getListeStations, ""))
				{	soap_flag_ns1__getListeStations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getListeStations(struct soap *soap, const struct __ns1__getListeStations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getListeStations(soap, tag?tag:"-ns1:getListeStations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getListeStations * SOAP_FMAC4 soap_get___ns1__getListeStations(struct soap *soap, struct __ns1__getListeStations *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getListeStations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getListeStations * SOAP_FMAC2 soap_instantiate___ns1__getListeStations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getListeStations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getListeStations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__getListeStations);
		if (size)
			*size = sizeof(struct __ns1__getListeStations);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__getListeStations[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getListeStations);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getListeStations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getListeStations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getListeStations %p -> %p\n", q, p));
	*(struct __ns1__getListeStations*)p = *(struct __ns1__getListeStations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getListeLignes(struct soap *soap, struct __ns1__getListeLignes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getListeLignes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getListeLignes(struct soap *soap, const struct __ns1__getListeLignes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getListeLignes(soap, &a->ns1__getListeLignes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getListeLignes(struct soap *soap, const char *tag, int id, const struct __ns1__getListeLignes *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getListeLignes(soap, "ns1:getListeLignes", -1, &a->ns1__getListeLignes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getListeLignes * SOAP_FMAC4 soap_in___ns1__getListeLignes(struct soap *soap, const char *tag, struct __ns1__getListeLignes *a, const char *type)
{
	size_t soap_flag_ns1__getListeLignes = 1;
	short soap_flag;
	a = (struct __ns1__getListeLignes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getListeLignes, sizeof(struct __ns1__getListeLignes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getListeLignes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getListeLignes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getListeLignes(soap, "ns1:getListeLignes", &a->ns1__getListeLignes, ""))
				{	soap_flag_ns1__getListeLignes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getListeLignes(struct soap *soap, const struct __ns1__getListeLignes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getListeLignes(soap, tag?tag:"-ns1:getListeLignes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getListeLignes * SOAP_FMAC4 soap_get___ns1__getListeLignes(struct soap *soap, struct __ns1__getListeLignes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getListeLignes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getListeLignes * SOAP_FMAC2 soap_instantiate___ns1__getListeLignes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getListeLignes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getListeLignes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__getListeLignes);
		if (size)
			*size = sizeof(struct __ns1__getListeLignes);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__getListeLignes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getListeLignes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getListeLignes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getListeLignes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getListeLignes %p -> %p\n", q, p));
	*(struct __ns1__getListeLignes*)p = *(struct __ns1__getListeLignes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMessages(struct soap *soap, struct __ns1__getMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMessages = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMessages(struct soap *soap, const struct __ns1__getMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getMessages(soap, &a->ns1__getMessages);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMessages(struct soap *soap, const char *tag, int id, const struct __ns1__getMessages *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getMessages(soap, "ns1:getMessages", -1, &a->ns1__getMessages, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMessages * SOAP_FMAC4 soap_in___ns1__getMessages(struct soap *soap, const char *tag, struct __ns1__getMessages *a, const char *type)
{
	size_t soap_flag_ns1__getMessages = 1;
	short soap_flag;
	a = (struct __ns1__getMessages *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMessages, sizeof(struct __ns1__getMessages), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMessages(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMessages && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getMessages(soap, "ns1:getMessages", &a->ns1__getMessages, ""))
				{	soap_flag_ns1__getMessages--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMessages(struct soap *soap, const struct __ns1__getMessages *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMessages(soap, tag?tag:"-ns1:getMessages", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMessages * SOAP_FMAC4 soap_get___ns1__getMessages(struct soap *soap, struct __ns1__getMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMessages * SOAP_FMAC2 soap_instantiate___ns1__getMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMessages(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMessages, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __ns1__getMessages);
		if (size)
			*size = sizeof(struct __ns1__getMessages);
	}
	else
	{	cp->ptr = (void*)new (struct __ns1__getMessages[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMessages);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMessages*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMessages(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMessages %p -> %p\n", q, p));
	*(struct __ns1__getMessages*)p = *(struct __ns1__getMessages*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__verifBornePersoResponse(struct soap *soap, _ns1__verifBornePersoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__verifBornePersoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__verifBornePersoResponse(struct soap *soap, const char *tag, int id, _ns1__verifBornePersoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__verifBornePersoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__verifBornePersoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__verifBornePersoResponse(struct soap *soap, const char *tag, _ns1__verifBornePersoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__verifBornePersoResponse **)soap_malloc(soap, sizeof(_ns1__verifBornePersoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__verifBornePersoResponse *)soap_instantiate__ns1__verifBornePersoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__verifBornePersoResponse ** p = (_ns1__verifBornePersoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__verifBornePersoResponse, sizeof(_ns1__verifBornePersoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__verifBornePersoResponse(struct soap *soap, _ns1__verifBornePersoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__verifBornePersoResponse);
	if (soap_out_PointerTo_ns1__verifBornePersoResponse(soap, tag?tag:"ns1:verifBornePersoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__verifBornePersoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__verifBornePersoResponse(struct soap *soap, _ns1__verifBornePersoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__verifBornePersoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__verifBornePerso(struct soap *soap, _ns1__verifBornePerso *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__verifBornePerso))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__verifBornePerso(struct soap *soap, const char *tag, int id, _ns1__verifBornePerso *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__verifBornePerso);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__verifBornePerso ** SOAP_FMAC4 soap_in_PointerTo_ns1__verifBornePerso(struct soap *soap, const char *tag, _ns1__verifBornePerso **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__verifBornePerso **)soap_malloc(soap, sizeof(_ns1__verifBornePerso *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__verifBornePerso *)soap_instantiate__ns1__verifBornePerso(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__verifBornePerso ** p = (_ns1__verifBornePerso **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__verifBornePerso, sizeof(_ns1__verifBornePerso), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__verifBornePerso(struct soap *soap, _ns1__verifBornePerso *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__verifBornePerso);
	if (soap_out_PointerTo_ns1__verifBornePerso(soap, tag?tag:"ns1:verifBornePerso", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__verifBornePerso ** SOAP_FMAC4 soap_get_PointerTo_ns1__verifBornePerso(struct soap *soap, _ns1__verifBornePerso **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__verifBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createBornePersoResponse(struct soap *soap, _ns1__createBornePersoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createBornePersoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createBornePersoResponse(struct soap *soap, const char *tag, int id, _ns1__createBornePersoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createBornePersoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__createBornePersoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__createBornePersoResponse(struct soap *soap, const char *tag, _ns1__createBornePersoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__createBornePersoResponse **)soap_malloc(soap, sizeof(_ns1__createBornePersoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__createBornePersoResponse *)soap_instantiate__ns1__createBornePersoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__createBornePersoResponse ** p = (_ns1__createBornePersoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createBornePersoResponse, sizeof(_ns1__createBornePersoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createBornePersoResponse(struct soap *soap, _ns1__createBornePersoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__createBornePersoResponse);
	if (soap_out_PointerTo_ns1__createBornePersoResponse(soap, tag?tag:"ns1:createBornePersoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__createBornePersoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__createBornePersoResponse(struct soap *soap, _ns1__createBornePersoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createBornePersoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createBornePerso(struct soap *soap, _ns1__createBornePerso *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createBornePerso))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createBornePerso(struct soap *soap, const char *tag, int id, _ns1__createBornePerso *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createBornePerso);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__createBornePerso ** SOAP_FMAC4 soap_in_PointerTo_ns1__createBornePerso(struct soap *soap, const char *tag, _ns1__createBornePerso **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__createBornePerso **)soap_malloc(soap, sizeof(_ns1__createBornePerso *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__createBornePerso *)soap_instantiate__ns1__createBornePerso(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__createBornePerso ** p = (_ns1__createBornePerso **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createBornePerso, sizeof(_ns1__createBornePerso), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createBornePerso(struct soap *soap, _ns1__createBornePerso *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__createBornePerso);
	if (soap_out_PointerTo_ns1__createBornePerso(soap, tag?tag:"ns1:createBornePerso", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__createBornePerso ** SOAP_FMAC4 soap_get_PointerTo_ns1__createBornePerso(struct soap *soap, _ns1__createBornePerso **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__deleteLigneStationBornePersoResponse(struct soap *soap, _ns1__deleteLigneStationBornePersoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__deleteLigneStationBornePersoResponse(struct soap *soap, const char *tag, int id, _ns1__deleteLigneStationBornePersoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__deleteLigneStationBornePersoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__deleteLigneStationBornePersoResponse(struct soap *soap, const char *tag, _ns1__deleteLigneStationBornePersoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__deleteLigneStationBornePersoResponse **)soap_malloc(soap, sizeof(_ns1__deleteLigneStationBornePersoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__deleteLigneStationBornePersoResponse *)soap_instantiate__ns1__deleteLigneStationBornePersoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__deleteLigneStationBornePersoResponse ** p = (_ns1__deleteLigneStationBornePersoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__deleteLigneStationBornePersoResponse, sizeof(_ns1__deleteLigneStationBornePersoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__deleteLigneStationBornePersoResponse(struct soap *soap, _ns1__deleteLigneStationBornePersoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__deleteLigneStationBornePersoResponse);
	if (soap_out_PointerTo_ns1__deleteLigneStationBornePersoResponse(soap, tag?tag:"ns1:deleteLigneStationBornePersoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__deleteLigneStationBornePersoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__deleteLigneStationBornePersoResponse(struct soap *soap, _ns1__deleteLigneStationBornePersoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__deleteLigneStationBornePersoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__deleteLigneStationBornePerso(struct soap *soap, _ns1__deleteLigneStationBornePerso *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__deleteLigneStationBornePerso))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__deleteLigneStationBornePerso(struct soap *soap, const char *tag, int id, _ns1__deleteLigneStationBornePerso *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__deleteLigneStationBornePerso);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__deleteLigneStationBornePerso ** SOAP_FMAC4 soap_in_PointerTo_ns1__deleteLigneStationBornePerso(struct soap *soap, const char *tag, _ns1__deleteLigneStationBornePerso **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__deleteLigneStationBornePerso **)soap_malloc(soap, sizeof(_ns1__deleteLigneStationBornePerso *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__deleteLigneStationBornePerso *)soap_instantiate__ns1__deleteLigneStationBornePerso(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__deleteLigneStationBornePerso ** p = (_ns1__deleteLigneStationBornePerso **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__deleteLigneStationBornePerso, sizeof(_ns1__deleteLigneStationBornePerso), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__deleteLigneStationBornePerso(struct soap *soap, _ns1__deleteLigneStationBornePerso *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__deleteLigneStationBornePerso);
	if (soap_out_PointerTo_ns1__deleteLigneStationBornePerso(soap, tag?tag:"ns1:deleteLigneStationBornePerso", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__deleteLigneStationBornePerso ** SOAP_FMAC4 soap_get_PointerTo_ns1__deleteLigneStationBornePerso(struct soap *soap, _ns1__deleteLigneStationBornePerso **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__deleteLigneStationBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addLigneStationBornePersoResponse(struct soap *soap, _ns1__addLigneStationBornePersoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addLigneStationBornePersoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addLigneStationBornePersoResponse(struct soap *soap, const char *tag, int id, _ns1__addLigneStationBornePersoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addLigneStationBornePersoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addLigneStationBornePersoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addLigneStationBornePersoResponse(struct soap *soap, const char *tag, _ns1__addLigneStationBornePersoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addLigneStationBornePersoResponse **)soap_malloc(soap, sizeof(_ns1__addLigneStationBornePersoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addLigneStationBornePersoResponse *)soap_instantiate__ns1__addLigneStationBornePersoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addLigneStationBornePersoResponse ** p = (_ns1__addLigneStationBornePersoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addLigneStationBornePersoResponse, sizeof(_ns1__addLigneStationBornePersoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addLigneStationBornePersoResponse(struct soap *soap, _ns1__addLigneStationBornePersoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addLigneStationBornePersoResponse);
	if (soap_out_PointerTo_ns1__addLigneStationBornePersoResponse(soap, tag?tag:"ns1:addLigneStationBornePersoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addLigneStationBornePersoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addLigneStationBornePersoResponse(struct soap *soap, _ns1__addLigneStationBornePersoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addLigneStationBornePersoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addLigneStationBornePerso(struct soap *soap, _ns1__addLigneStationBornePerso *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addLigneStationBornePerso))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addLigneStationBornePerso(struct soap *soap, const char *tag, int id, _ns1__addLigneStationBornePerso *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addLigneStationBornePerso);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addLigneStationBornePerso ** SOAP_FMAC4 soap_in_PointerTo_ns1__addLigneStationBornePerso(struct soap *soap, const char *tag, _ns1__addLigneStationBornePerso **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addLigneStationBornePerso **)soap_malloc(soap, sizeof(_ns1__addLigneStationBornePerso *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addLigneStationBornePerso *)soap_instantiate__ns1__addLigneStationBornePerso(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addLigneStationBornePerso ** p = (_ns1__addLigneStationBornePerso **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addLigneStationBornePerso, sizeof(_ns1__addLigneStationBornePerso), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addLigneStationBornePerso(struct soap *soap, _ns1__addLigneStationBornePerso *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addLigneStationBornePerso);
	if (soap_out_PointerTo_ns1__addLigneStationBornePerso(soap, tag?tag:"ns1:addLigneStationBornePerso", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addLigneStationBornePerso ** SOAP_FMAC4 soap_get_PointerTo_ns1__addLigneStationBornePerso(struct soap *soap, _ns1__addLigneStationBornePerso **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addLigneStationBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getLigneStationBornePersoResponse(struct soap *soap, _ns1__getLigneStationBornePersoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getLigneStationBornePersoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getLigneStationBornePersoResponse(struct soap *soap, const char *tag, int id, _ns1__getLigneStationBornePersoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getLigneStationBornePersoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getLigneStationBornePersoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getLigneStationBornePersoResponse(struct soap *soap, const char *tag, _ns1__getLigneStationBornePersoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getLigneStationBornePersoResponse **)soap_malloc(soap, sizeof(_ns1__getLigneStationBornePersoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getLigneStationBornePersoResponse *)soap_instantiate__ns1__getLigneStationBornePersoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getLigneStationBornePersoResponse ** p = (_ns1__getLigneStationBornePersoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getLigneStationBornePersoResponse, sizeof(_ns1__getLigneStationBornePersoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getLigneStationBornePersoResponse(struct soap *soap, _ns1__getLigneStationBornePersoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getLigneStationBornePersoResponse);
	if (soap_out_PointerTo_ns1__getLigneStationBornePersoResponse(soap, tag?tag:"ns1:getLigneStationBornePersoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getLigneStationBornePersoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getLigneStationBornePersoResponse(struct soap *soap, _ns1__getLigneStationBornePersoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getLigneStationBornePersoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getLigneStationBornePerso(struct soap *soap, _ns1__getLigneStationBornePerso *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getLigneStationBornePerso))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getLigneStationBornePerso(struct soap *soap, const char *tag, int id, _ns1__getLigneStationBornePerso *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getLigneStationBornePerso);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getLigneStationBornePerso ** SOAP_FMAC4 soap_in_PointerTo_ns1__getLigneStationBornePerso(struct soap *soap, const char *tag, _ns1__getLigneStationBornePerso **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getLigneStationBornePerso **)soap_malloc(soap, sizeof(_ns1__getLigneStationBornePerso *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getLigneStationBornePerso *)soap_instantiate__ns1__getLigneStationBornePerso(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getLigneStationBornePerso ** p = (_ns1__getLigneStationBornePerso **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getLigneStationBornePerso, sizeof(_ns1__getLigneStationBornePerso), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getLigneStationBornePerso(struct soap *soap, _ns1__getLigneStationBornePerso *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getLigneStationBornePerso);
	if (soap_out_PointerTo_ns1__getLigneStationBornePerso(soap, tag?tag:"ns1:getLigneStationBornePerso", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getLigneStationBornePerso ** SOAP_FMAC4 soap_get_PointerTo_ns1__getLigneStationBornePerso(struct soap *soap, _ns1__getLigneStationBornePerso **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getLigneStationBornePerso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getInfoTraficResponse(struct soap *soap, _ns1__getInfoTraficResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getInfoTraficResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getInfoTraficResponse(struct soap *soap, const char *tag, int id, _ns1__getInfoTraficResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getInfoTraficResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getInfoTraficResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getInfoTraficResponse(struct soap *soap, const char *tag, _ns1__getInfoTraficResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getInfoTraficResponse **)soap_malloc(soap, sizeof(_ns1__getInfoTraficResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getInfoTraficResponse *)soap_instantiate__ns1__getInfoTraficResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getInfoTraficResponse ** p = (_ns1__getInfoTraficResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getInfoTraficResponse, sizeof(_ns1__getInfoTraficResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getInfoTraficResponse(struct soap *soap, _ns1__getInfoTraficResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getInfoTraficResponse);
	if (soap_out_PointerTo_ns1__getInfoTraficResponse(soap, tag?tag:"ns1:getInfoTraficResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getInfoTraficResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getInfoTraficResponse(struct soap *soap, _ns1__getInfoTraficResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getInfoTraficResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getInfoTrafic(struct soap *soap, _ns1__getInfoTrafic *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getInfoTrafic))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getInfoTrafic(struct soap *soap, const char *tag, int id, _ns1__getInfoTrafic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getInfoTrafic);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getInfoTrafic ** SOAP_FMAC4 soap_in_PointerTo_ns1__getInfoTrafic(struct soap *soap, const char *tag, _ns1__getInfoTrafic **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getInfoTrafic **)soap_malloc(soap, sizeof(_ns1__getInfoTrafic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getInfoTrafic *)soap_instantiate__ns1__getInfoTrafic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getInfoTrafic ** p = (_ns1__getInfoTrafic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getInfoTrafic, sizeof(_ns1__getInfoTrafic), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getInfoTrafic(struct soap *soap, _ns1__getInfoTrafic *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getInfoTrafic);
	if (soap_out_PointerTo_ns1__getInfoTrafic(soap, tag?tag:"ns1:getInfoTrafic", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getInfoTrafic ** SOAP_FMAC4 soap_get_PointerTo_ns1__getInfoTrafic(struct soap *soap, _ns1__getInfoTrafic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getInfoTrafic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTempsParStationResponse(struct soap *soap, _ns1__getTempsParStationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTempsParStationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTempsParStationResponse(struct soap *soap, const char *tag, int id, _ns1__getTempsParStationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTempsParStationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTempsParStationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTempsParStationResponse(struct soap *soap, const char *tag, _ns1__getTempsParStationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTempsParStationResponse **)soap_malloc(soap, sizeof(_ns1__getTempsParStationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTempsParStationResponse *)soap_instantiate__ns1__getTempsParStationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTempsParStationResponse ** p = (_ns1__getTempsParStationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTempsParStationResponse, sizeof(_ns1__getTempsParStationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTempsParStationResponse(struct soap *soap, _ns1__getTempsParStationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTempsParStationResponse);
	if (soap_out_PointerTo_ns1__getTempsParStationResponse(soap, tag?tag:"ns1:getTempsParStationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTempsParStationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTempsParStationResponse(struct soap *soap, _ns1__getTempsParStationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTempsParStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTempsParStation(struct soap *soap, _ns1__getTempsParStation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTempsParStation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTempsParStation(struct soap *soap, const char *tag, int id, _ns1__getTempsParStation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTempsParStation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTempsParStation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTempsParStation(struct soap *soap, const char *tag, _ns1__getTempsParStation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTempsParStation **)soap_malloc(soap, sizeof(_ns1__getTempsParStation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTempsParStation *)soap_instantiate__ns1__getTempsParStation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTempsParStation ** p = (_ns1__getTempsParStation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTempsParStation, sizeof(_ns1__getTempsParStation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTempsParStation(struct soap *soap, _ns1__getTempsParStation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTempsParStation);
	if (soap_out_PointerTo_ns1__getTempsParStation(soap, tag?tag:"ns1:getTempsParStation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTempsParStation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTempsParStation(struct soap *soap, _ns1__getTempsParStation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTempsParStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getListeStationsProchesResponse(struct soap *soap, _ns1__getListeStationsProchesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getListeStationsProchesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getListeStationsProchesResponse(struct soap *soap, const char *tag, int id, _ns1__getListeStationsProchesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getListeStationsProchesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getListeStationsProchesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getListeStationsProchesResponse(struct soap *soap, const char *tag, _ns1__getListeStationsProchesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getListeStationsProchesResponse **)soap_malloc(soap, sizeof(_ns1__getListeStationsProchesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getListeStationsProchesResponse *)soap_instantiate__ns1__getListeStationsProchesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getListeStationsProchesResponse ** p = (_ns1__getListeStationsProchesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getListeStationsProchesResponse, sizeof(_ns1__getListeStationsProchesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getListeStationsProchesResponse(struct soap *soap, _ns1__getListeStationsProchesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getListeStationsProchesResponse);
	if (soap_out_PointerTo_ns1__getListeStationsProchesResponse(soap, tag?tag:"ns1:getListeStationsProchesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getListeStationsProchesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getListeStationsProchesResponse(struct soap *soap, _ns1__getListeStationsProchesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getListeStationsProchesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getListeStationsProches(struct soap *soap, _ns1__getListeStationsProches *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getListeStationsProches))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getListeStationsProches(struct soap *soap, const char *tag, int id, _ns1__getListeStationsProches *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getListeStationsProches);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getListeStationsProches ** SOAP_FMAC4 soap_in_PointerTo_ns1__getListeStationsProches(struct soap *soap, const char *tag, _ns1__getListeStationsProches **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getListeStationsProches **)soap_malloc(soap, sizeof(_ns1__getListeStationsProches *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getListeStationsProches *)soap_instantiate__ns1__getListeStationsProches(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getListeStationsProches ** p = (_ns1__getListeStationsProches **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getListeStationsProches, sizeof(_ns1__getListeStationsProches), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getListeStationsProches(struct soap *soap, _ns1__getListeStationsProches *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getListeStationsProches);
	if (soap_out_PointerTo_ns1__getListeStationsProches(soap, tag?tag:"ns1:getListeStationsProches", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getListeStationsProches ** SOAP_FMAC4 soap_get_PointerTo_ns1__getListeStationsProches(struct soap *soap, _ns1__getListeStationsProches **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getListeStationsProches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getListeStationsParLigneResponse(struct soap *soap, _ns1__getListeStationsParLigneResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getListeStationsParLigneResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getListeStationsParLigneResponse(struct soap *soap, const char *tag, int id, _ns1__getListeStationsParLigneResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getListeStationsParLigneResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getListeStationsParLigneResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getListeStationsParLigneResponse(struct soap *soap, const char *tag, _ns1__getListeStationsParLigneResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getListeStationsParLigneResponse **)soap_malloc(soap, sizeof(_ns1__getListeStationsParLigneResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getListeStationsParLigneResponse *)soap_instantiate__ns1__getListeStationsParLigneResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getListeStationsParLigneResponse ** p = (_ns1__getListeStationsParLigneResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getListeStationsParLigneResponse, sizeof(_ns1__getListeStationsParLigneResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getListeStationsParLigneResponse(struct soap *soap, _ns1__getListeStationsParLigneResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getListeStationsParLigneResponse);
	if (soap_out_PointerTo_ns1__getListeStationsParLigneResponse(soap, tag?tag:"ns1:getListeStationsParLigneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getListeStationsParLigneResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getListeStationsParLigneResponse(struct soap *soap, _ns1__getListeStationsParLigneResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getListeStationsParLigneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getListeStationsParLigne(struct soap *soap, _ns1__getListeStationsParLigne *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getListeStationsParLigne))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getListeStationsParLigne(struct soap *soap, const char *tag, int id, _ns1__getListeStationsParLigne *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getListeStationsParLigne);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getListeStationsParLigne ** SOAP_FMAC4 soap_in_PointerTo_ns1__getListeStationsParLigne(struct soap *soap, const char *tag, _ns1__getListeStationsParLigne **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getListeStationsParLigne **)soap_malloc(soap, sizeof(_ns1__getListeStationsParLigne *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getListeStationsParLigne *)soap_instantiate__ns1__getListeStationsParLigne(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getListeStationsParLigne ** p = (_ns1__getListeStationsParLigne **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getListeStationsParLigne, sizeof(_ns1__getListeStationsParLigne), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getListeStationsParLigne(struct soap *soap, _ns1__getListeStationsParLigne *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getListeStationsParLigne);
	if (soap_out_PointerTo_ns1__getListeStationsParLigne(soap, tag?tag:"ns1:getListeStationsParLigne", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getListeStationsParLigne ** SOAP_FMAC4 soap_get_PointerTo_ns1__getListeStationsParLigne(struct soap *soap, _ns1__getListeStationsParLigne **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getListeStationsParLigne(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getListeStationsResponse(struct soap *soap, _ns1__getListeStationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getListeStationsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getListeStationsResponse(struct soap *soap, const char *tag, int id, _ns1__getListeStationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getListeStationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getListeStationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getListeStationsResponse(struct soap *soap, const char *tag, _ns1__getListeStationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getListeStationsResponse **)soap_malloc(soap, sizeof(_ns1__getListeStationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getListeStationsResponse *)soap_instantiate__ns1__getListeStationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getListeStationsResponse ** p = (_ns1__getListeStationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getListeStationsResponse, sizeof(_ns1__getListeStationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getListeStationsResponse(struct soap *soap, _ns1__getListeStationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getListeStationsResponse);
	if (soap_out_PointerTo_ns1__getListeStationsResponse(soap, tag?tag:"ns1:getListeStationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getListeStationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getListeStationsResponse(struct soap *soap, _ns1__getListeStationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getListeStationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getListeStations(struct soap *soap, _ns1__getListeStations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getListeStations))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getListeStations(struct soap *soap, const char *tag, int id, _ns1__getListeStations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getListeStations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getListeStations ** SOAP_FMAC4 soap_in_PointerTo_ns1__getListeStations(struct soap *soap, const char *tag, _ns1__getListeStations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getListeStations **)soap_malloc(soap, sizeof(_ns1__getListeStations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getListeStations *)soap_instantiate__ns1__getListeStations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getListeStations ** p = (_ns1__getListeStations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getListeStations, sizeof(_ns1__getListeStations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getListeStations(struct soap *soap, _ns1__getListeStations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getListeStations);
	if (soap_out_PointerTo_ns1__getListeStations(soap, tag?tag:"ns1:getListeStations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getListeStations ** SOAP_FMAC4 soap_get_PointerTo_ns1__getListeStations(struct soap *soap, _ns1__getListeStations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getListeStations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getListeLignesResponse(struct soap *soap, _ns1__getListeLignesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getListeLignesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getListeLignesResponse(struct soap *soap, const char *tag, int id, _ns1__getListeLignesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getListeLignesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getListeLignesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getListeLignesResponse(struct soap *soap, const char *tag, _ns1__getListeLignesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getListeLignesResponse **)soap_malloc(soap, sizeof(_ns1__getListeLignesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getListeLignesResponse *)soap_instantiate__ns1__getListeLignesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getListeLignesResponse ** p = (_ns1__getListeLignesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getListeLignesResponse, sizeof(_ns1__getListeLignesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getListeLignesResponse(struct soap *soap, _ns1__getListeLignesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getListeLignesResponse);
	if (soap_out_PointerTo_ns1__getListeLignesResponse(soap, tag?tag:"ns1:getListeLignesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getListeLignesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getListeLignesResponse(struct soap *soap, _ns1__getListeLignesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getListeLignesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getListeLignes(struct soap *soap, _ns1__getListeLignes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getListeLignes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getListeLignes(struct soap *soap, const char *tag, int id, _ns1__getListeLignes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getListeLignes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getListeLignes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getListeLignes(struct soap *soap, const char *tag, _ns1__getListeLignes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getListeLignes **)soap_malloc(soap, sizeof(_ns1__getListeLignes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getListeLignes *)soap_instantiate__ns1__getListeLignes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getListeLignes ** p = (_ns1__getListeLignes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getListeLignes, sizeof(_ns1__getListeLignes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getListeLignes(struct soap *soap, _ns1__getListeLignes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getListeLignes);
	if (soap_out_PointerTo_ns1__getListeLignes(soap, tag?tag:"ns1:getListeLignes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getListeLignes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getListeLignes(struct soap *soap, _ns1__getListeLignes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getListeLignes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getMessagesResponse(struct soap *soap, _ns1__getMessagesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getMessagesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getMessagesResponse(struct soap *soap, const char *tag, int id, _ns1__getMessagesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getMessagesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getMessagesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getMessagesResponse(struct soap *soap, const char *tag, _ns1__getMessagesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getMessagesResponse **)soap_malloc(soap, sizeof(_ns1__getMessagesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getMessagesResponse *)soap_instantiate__ns1__getMessagesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getMessagesResponse ** p = (_ns1__getMessagesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getMessagesResponse, sizeof(_ns1__getMessagesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getMessagesResponse(struct soap *soap, _ns1__getMessagesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getMessagesResponse);
	if (soap_out_PointerTo_ns1__getMessagesResponse(soap, tag?tag:"ns1:getMessagesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getMessagesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getMessagesResponse(struct soap *soap, _ns1__getMessagesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getMessages(struct soap *soap, _ns1__getMessages *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getMessages))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getMessages(struct soap *soap, const char *tag, int id, _ns1__getMessages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getMessages);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getMessages ** SOAP_FMAC4 soap_in_PointerTo_ns1__getMessages(struct soap *soap, const char *tag, _ns1__getMessages **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getMessages **)soap_malloc(soap, sizeof(_ns1__getMessages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getMessages *)soap_instantiate__ns1__getMessages(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getMessages ** p = (_ns1__getMessages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getMessages, sizeof(_ns1__getMessages), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getMessages(struct soap *soap, _ns1__getMessages *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getMessages);
	if (soap_out_PointerTo_ns1__getMessages(soap, tag?tag:"ns1:getMessages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getMessages ** SOAP_FMAC4 soap_get_PointerTo_ns1__getMessages(struct soap *soap, _ns1__getMessages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
